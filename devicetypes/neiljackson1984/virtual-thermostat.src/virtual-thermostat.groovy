/**
 *  Virtual Thermostat
 *
 *  Copyright 2018 Neil Jackson
 *  This device handler is designed to be created as a child device of the Virtual Thermostat SmartApp.
 */
metadata {
	definition (name: "Virtual Thermostat", namespace: "neiljackson1984", author: "Neil Jackson") {
    	//TAGGING CAPABILITIES: ('tagging' implies that these capabilities have no attributes, and have no commands)
        
        capability "Actuator"  //The "Actuator" capability is simply a marker to inform SmartThings that this device has commands     
        //attributes: (none)
        //commands:  (none)
        
        capability "Sensor"   //The "Sensor" capability is simply a marker to inform SmartThings that this device has attributes     
        //attributes: (none)
        //commands:  (none)
        
        
		capability "Thermostat Cooling Setpoint"
        //attributes: coolingSetpoint
        //commands: setCoolingSetpoint
        
		capability "Thermostat Fan Mode"
        //attributes: thermostatFanMode, supportedThermostatFanModes
        //commands: fanAuto, fanCirculate, fanOn, setThermostatFanMode
        
		capability "Thermostat Heating Setpoint"
        //attributes: heatingSetpoint
        //commands: setHeatingSetpoint
        
		capability "Thermostat Mode"
        //attributes: thermostatMode, supportedThermostatModes
        //commands: auto, cool, emergencyHeat, heat, 'off', setThermostatMode
        
		capability "Thermostat Operating State"
        //attributes: thermostatOperatingState
        //commands: (none)
        
		//  capability "Thermostat Schedule"
        //  //attributes: schedule
        //  //commands: setSchedule
        
        capability "Temperature Measurement"
        //attributes: temperature
        //commands: (none)
        
        attribute ("setpoint", "number");
        command( "setSetpoint", ["number"]);  // I might as well leave this as an internal function since it is not part of a published standard. -- ahah- i must designate it an official command in order to be able to call it as an action from a controlTile.
        
        attribute( "controlError", "number" ); //this will be (actual temperature) - (desired temperature)
        attribute( "integralOfControlError", "number" );
        attribute( "derivativeOfControlError", "number" );
        attribute( "controlOutputForce", "number" );
        attribute( "lastControlUpdateTime", "number" );
        attribute( "controllerIterationReport", "string" );  // a human-readable multi-line report that will be generated by updateController().

        
        //these commands exist solely to support the tile-based ui:
        command("switchMode");
        command("increaseSetpoint");
        command("decreaseSetpoint");
        command("updateController");
        command("resetIntegral");
        command("manualUpdateController");
}


	simulator {
		// TODO: define status and reply messages here
	}

	tiles(scale : 2) {
		multiAttributeTile(name:"thermostatMulti", type:"thermostat", width:6, height:4, canChangeIcon: true) {
			tileAttribute("device.temperature", key: "PRIMARY_CONTROL") {
				attributeState("arbitraryStringHere", label:'${currentValue}', defaultState: true)
			}
            tileAttribute("device.setpoint", key: "VALUE_CONTROL") {
				attributeState("VALUE_UP", label: '${currentValue.round(2)}', action: "increaseSetpoint")
                attributeState("VALUE_DOWN", label: '${currentValue.toString().toFloat().round(2)}', action: "decreaseSetpoint")
			}
			tileAttribute("device.thermostatOperatingState", key: "OPERATING_STATE") {
				attributeState("idle", backgroundColor:"#44b621")
				attributeState("heating", backgroundColor:"#ffa81e")
                attributeState("cooling", backgroundColor:"#00A0DC")
			}
			tileAttribute("device.thermostatMode", key: "THERMOSTAT_MODE") {
				attributeState("default", label:'mode: undefined', defaultState: true)
                attributeState("off", label:'mode: ${name}')
                attributeState("heat", label:'mode: ${name}')
                attributeState("cool", label:'mode: ${name}')
				attributeState("auto", label:'mode: ${name}')
			}
            tileAttribute("device.heatingSetpoint", key: "HEATING_SETPOINT") {
            	attributeState("arbitraryStringHere", label:'${currentValue}')
            }
            tileAttribute("device.coolingSetpoint", key: "COOLING_SETPOINT") {
            	attributeState("arbitraryStringHere", label:'${currentValue}')
            }
		}
        standardTile("mode", "device.thermostatMode", width: 2, height: 2) {
            state "off", label:'mode: ${name}', action:"switchMode", nextState:"heat"
			state "heat", label:'mode: ${name}', action:"switchMode", nextState:"off", icon:"http://cdn.device-icons.smartthings.com/Home/home29-icn@2x.png"
        }

        valueTile("currentTemperature", "device.temperature", width: 2, height: 2, decoration: "flat"){
        	state "default", label:'currentTemperature: ${currentValue}', unit: "ahoy", defaultState:true
        }

        valueTile("setpoint", "device.setpoint", width: 2, height: 2, decoration: "flat"){
        	state "default", label:'setpoint: ${currentValue}', unit: "ahoy", defaultState:true
        }
        
        valueTile("controlError", "device.controlError", width: 2, height: 2, decoration: "flat"){
        	state "default", label:'controlError: ${currentValue}', unit: "ahoy", defaultState:true
        }
        
        valueTile("integralOfControlError", "device.integralOfControlError", width: 2, height: 2, decoration: "flat"){
        	state "default", label:'integralOfControlError: ${currentValue}', unit: "ahoy", defaultState:true
        }
       
        valueTile("derivativeOfControlError", "device.derivativeOfControlError", width: 2, height: 2, decoration: "flat"){
        	state "default", label:'derivativeOfControlError: ${currentValue}', unit: "ahoy", defaultState:true
        }
        
        valueTile("controlOutputForce", "device.controlOutputForce", width: 2, height: 2, decoration: "flat"){
        	state "default", label:'controlOutputForce: ${currentValue}', unit: "ahoy", defaultState:true
        }
        
        valueTile("lastControlUpdateTime", "device.lastControlUpdateTime", width: 2, height: 2, decoration: "flat"){
        	state "default", label:'lastControlUpdateTime: ${currentValue}', unit: "ahoy", defaultState:true
        }
        
        standardTile("manualUpdateController", "whatever", width: 2, height: 2, decoration: "flat"){
        	state "default", label:'manualUpdateController()', unit: "ahoy", defaultState:true, action:"manualUpdateController"
        }
        
        standardTile("resetIntegral", "whatever", width: 2, height: 2, decoration: "flat"){
        	state "default", label:'resetIntegral()', unit: "ahoy", defaultState:true, action:"resetIntegral"
        }
        
        standardTile("controllerIterationReport", "device.controllerIterationReport", width: 6, height: 3, decoration: "flat", alignment: 'left', align: 'left', style: 'text-align:left'){
        	state "default", label:'${currentValue}', defaultState:true //action:"resetIntegral"
        }
        
        
        
       ////  controlTile(
		////  	"setpointControlTile",            // String tileName -- a unique name, to be used as an argument to the main() or details() function below
		////  	"device.setpoint",                // String attributeName 
		////  	"control",                        // String controlType  --  expected to be one of {"slider", "control"}
       ////      width:                     3,   // Integer	controls how wide the tile is. Default is 1.
       ////      height:                    3,   // Integer	controls how tall this tile is. Default is 1.
       ////      canChangeIcon:         false,   // Boolean	true to allow the user to pick their own icon. Defaults to false.
       ////      canChangeBackground:   false,   // Boolean	true to allow a user to choose their own background image for the tile. Defaults to false.
       ////      decoration:           'flat',   // String	specify "flat" for the tile to render without a ring.
       ////      //range:                   null,   // String	used to specify a custom range. In the form of "(<lower bound>..<upper bound>)"
       ////      inactiveLabel:         false    //undocumented options
       ////  ){
       ////  	state(
       ////                                  "setpoint",    // String stateName - the name of the attribute value for which to display this state for.
       ////          action:           'setSetpoint',    // String	the action to take when this tile is pressed. The form is <capabilityReference>.<command>.
       ////          //backgroundColor:           null,    // String	a hexadecimal color code to use for the background color. This has no effect if the tile has decoration: “flat”.
       ////          //backgroundColors:          null,    // 	String	specify a list of maps of attribute values and colors. The mobile app will match and interpolate between these entries to select a color based on the value of the attribute.
       ////          defaultState:              true,    // 	Boolean	specify true if this state should be the active state displayed for this tile.
       ////          //icon:                      null,    // 	String	the identifier of the icon to use for this state.
       ////         label: 'ahoy'                       // 	String	the label for this state. 
       ////     )
       ////     state("VALUE_UP", label: '${currentValue.round(2)}', action: "increaseSetpoint")
       ////     state("VALUE_DOWN", label: '${currentValue.toString().toFloat().round(2)}', action: "decreaseSetpoint")
       ////  }
        

        main ("thermostatMulti")
        details(
        	[
            	"thermostatMulti", 
                "mode", 
                "currentTemperature",
                "setpoint", 
                "controlError", 
                "integralOfControlError",
                "derivativeOfControlError",
                "controlOutputForce",
                "lastControlUpdateTime",
                "manualUpdateController",
                "resetIntegral",
                "setpointControlTile",
                "controllerIterationReport"
            ]
        )
    }
    
    preferences{
    	section(){
            paragraph("the controller will wait this long after changing the state of a heater or cooler before changing the state again. (prevents rapid cycling)");
            //Remember, Multiple page preferences and dynamic preferences pages are not supported in Device Handlers (only in SmartApps).
            // the smartapps preferences pages are much more flexible than the device preferences page, so perhaps we ought to put all preference entry there.
            input( 
                name: "holdoffDuration",
                title: "holdoffDuration (seconds): \nthe controller will wait this long after changing the state of a heater or cooler before changing the state again. (prevents rapid cycling)", 
                type: "number",
                description: "the controller will wait this long after changing the state of a heater or cooler before changing the state again. (prevents rapid cycling)", 
                required: false, 
                defaultValue: getHoldoffDuration()
            );
            
            input( 
                name: "pCoefficient",
                title: "pCoefficient ([output force]/Kelvin): \nThis is the p coefficient of the PID controller.", 
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getPCoefficient()
            );
            
            input( 
                name: "iCoefficient",
                title: "iCoefficient ([output force]/(Kelvin * seconds): \nThis is the i coefficient of the PID controller.", 
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getICoefficient()
            );
            
            input( 
                name: "dCoefficient",
                title: "dCoefficient ([output force]/(Kelvin/seconds): \nThis is the d coefficient of the PID controller. (not yet supported - this value will be ignored.)", 
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getDCoefficient()
            );
            
            input( 
                name: "powerOfHeaters",
                title: "powerOfHeaters ([output force]): \nThis is an input that allows you to tell the controller what (magnitude of) the power of the heaters (collectively) is.  " + 
                	"Because the ultimate output of the controller is just one of the the three values {heat, cool, or off}, the meaning of the powerOfHeaters setting is not " + 
                    "well-defined in physical terms.  The effect of powerOfHeaters and powerOfCoolers is to set the relative size of the off-to-heat and off-to-cool deadbands." +
                    "the algorithm will attend to only the absolute value, and not the sign, of this number."
                    ,
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getPowerOfHeaters()
            );
            
            input( 
                name: "powerOfCoolers",
                title: "powerOfCoolers([output force]): \nAnalogous to powerOfHeaters, decribed above.", 
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getPowerOfCoolers()
            );
            
        }
    }
}


//=============functions that serve as click handlers for the tile-based ui:
def switchMode()
{
 	log.debug "switchMode was called ";//with arg: " + arg;
}

def increaseSetpoint()
{
	log.debug "increaseSetpoint was called "//with arg: " + arg;
    nudgeSetpoint(+0.1);
}

def decreaseSetpoint()
{
	log.debug "decreaseSetpoint was called"// with arg: " + arg;
    nudgeSetpoint(-0.1);
    
}

def nudgeSetpoint(x)
{
	setSetpoint((device.currentState("setpoint").getFloatValue() + x).round(2));
}

def resetIntegral()
{
	sendEvent(name: "integralOfControlError",   value: 0.0, unit: "K*s");
    //updateController();
}

def manualUpdateController()
{
	updateController(cause:"button click");
}


//==========================functions that serve as getters for the preferences, which are necessary to provide the default values in case the user has never clicked through the preferences page (and therefore the settings object isn't populated with all  of the keys declared in the preferences metadata above)
def getHoldoffDuration() {
	def defaultHoldoffDuration = 113;
    return (settings?.containsKey("holdoffDuration") ? settings["holdoffDuration"] : defaultHoldoffDuration);
}

def getPCoefficient() {
	def defaultPCoefficient = -1;
    return (settings?.containsKey("pCoefficient") ? settings["pCoefficient"] : defaultPCoefficient);
}

def getICoefficient() {
	def defaultICoefficient = -0.000001;
    return (settings?.containsKey("iCoefficient") ? settings["iCoefficient"] : defaultICoefficient);
}

def getDCoefficient() {
	def defaultDCoefficient = 0;
    return (settings?.containsKey("dCoefficient") ? settings["dCoefficient"] : defaultDCoefficient);
}

def getPowerOfHeaters() {
	def defaultPowerOfHeaters = 1;
    return (settings?.containsKey("powerOfHeaters") ? settings["powerOfHeaters"] : defaultPowerOfHeaters);
}

def getPowerOfCoolers() {
	def defaultPowerOfCoolers = 1;
    return (settings?.containsKey("powerOfCoolers") ? settings["powerOfCoolers"] : defaultPowerOfCoolers);
}

// parse events into attributes
def parse(String description) {
	log.debug "Parsing '${description}'"
	// TODO: handle 'coolingSetpoint' attribute
	// TODO: handle 'thermostatFanMode' attribute
	// TODO: handle 'supportedThermostatFanModes' attribute
	// TODO: handle 'heatingSetpoint' attribute
	// TODO: handle 'thermostatMode' attribute
	// TODO: handle 'supportedThermostatModes' attribute
	// TODO: handle 'thermostatOperatingState' attribute
	// TODO: handle 'schedule' attribute
	// TODO: handle 'thermostatSetpoint' attribute
}

def setTemperature(float value, String unit)
{
	//we prefer not to do a pass through toSiValue to avoid creating a number with a lot of digits after the decimal point, which there is no good way to round at the time of display, and so looks ugly in the ui.
	float valueInLocalUnits = (unit == location.getTemperatureScale()   ?    value :  toValueInLocalUnits(toSiValue(value, unit), "K"));   
    sendEvent(name: "temperature",  value: valueInLocalUnits, unit: location.getTemperatureScale());
    // I am passing the new temperature to updateController as an argument rather than letting updateController() read the latest state because I suspect that the above sendEvent() will not have taken effect fully when I call updateController() immediately below
    updateController(newTemperature: toSiValue(value, unit), cause: "temperature change");
}

def setTemperature(state)
{
	setTemperature(state.getFloatValue(), state.getUnit());
}

//the parent SmartApp will invoke this method to tell the virtual thermostat to take a look at the thermometer's current reading and
// take action as needed.  This is where the meat of the control algorithm is.
def updateController(/*Map*/ options=[])
{
	//the SmartThings documentation (see https://docs.smartthings.com/en/latest/cloud-and-lan-connected-device-types-developers-guide/building-lan-connected-device-types/building-the-service-manager.html?highlight=parent#best-practices)
    // mentions that the best practice is to not have a child device make calls to the parent smartapp, but instead have the
    // parent smart app pass all necessary information to the methods of the child device as arguments.
    // I am intentionally violating that rule here to see what happens and because it seems cleaner to me
    // to have the child device retrieve the temperature from the parent.
    // Then again, I would intuitively think that a device ought to be able to subscribe to events from other devices (which is not the way it really is)
    // so maybe my mental model of a device is a bit different than that intended by the SmartThings architects.
	// update the temperature attribute of this virtual thermostat device to match the temperature attribute of the thermometer of the parent smartApp.
    // (The documentation does not even mention that a device has a getParent() method. )
    // there is a lot of overlap between the concept of SmartApp and the concept of Device.
    
    long currentTime = (new Date()).getTime();
    float temperature = options.newTemperature ?: toSiValue(device.currentState("temperature")); //the current temperature, expressed in si units (i.e. kelvin)

    log.debug("temperature: " + temperature);
    
    
    long lastControlUpdateTime = device.currentState("lastControlUpdateTime")?.getLongValue() ?: currentTime ;  //hopefully this won't throw an error when it is run for the first tame (meaning that no states have been logged for lastControlUpdateTime)
    //currentTime and lastControlUpdateTime are both a whole number of milliseconds.
    
    //all of these float values will be kept in si units.
    float lastControlError                        = device.currentState("controlError")?.getFloatValue()                ?: 0;                 //hopefully this will return zero and not throw an error in the case where no states for this attribute have yet been logged (which would happen on the firt execution of updateConttroller()
	float lastDerivativeOfControlError            = device.currentState("derivativeOfControlError")?.getFloatValue()    ?: 0;     //hopefully this will return zero and not throw an error in the case where no states for this attribute have yet been logged (which would happen on the firt execution of updateConttroller()
    float lastIntegralOfControlError              = device.currentState("integralOfControlError")?.getFloatValue()      ?: 0;        //hopefully this will return zero and not throw an error in the case where no states for this attribute have yet been logged (which would happen on the firt execution of updateConttroller()
    float lastControlOutputForce                  = device.currentState("controlOutputForce")?.getFloatValue()          ?: 0;
    float lastTemperature                         = toSiValue(device.currentState("temperature"))                       ?: 0;
    float timeElapsedSinceLastUpdate              =  (((float)(currentTime - lastControlUpdateTime))/1000.0);

    
    
   //read the current setpoint
   float setpoint = toSiValue(device.currentState("setpoint"));
   
   //compute the error
   float controlError = temperature - setpoint;
   
   //compute the derivative of the error  
   float derivativeOfControlError;
   if(currentTime == lastControlUpdateTime) //should we also check whether currentTime < lastControlUpdateTime ? Would that ever happen?
   {
   		derivativeOfControlError = lastDerivativeOfControlError;
   } else {
   		derivativeOfControlError = (controlError - lastControlError) / timeElapsedSinceLastUpdate;
   }
   
   //compute the integral of the control error
   float integralOfControlError = lastIntegralOfControlError + lastControlError * timeElapsedSinceLastUpdate;
   
   log.debug("getICoefficient(): " + getICoefficient());
   
   //compute controlOutputForce
   float controlOutputForce = 
   		  getPCoefficient() * controlError + getICoefficient() * integralOfControlError + getDCoefficient() * derivativeOfControlError;



    //store the necessary state information to be used on the next pass (and for anyone who happens to subscribe to these attributes)
    sendEvent(name: "lastControlUpdateTime",    value: currentTime);
    sendEvent(name: "controlError",             value: controlError, unit: "K"); //to do : express the controlError in the units specified by the location temperature units preference.
    sendEvent(name: "derivativeOfControlError", value: derivativeOfControlError, unit: "K/s");
    sendEvent(name: "integralOfControlError",   value: integralOfControlError, unit: "K*s");
    setControlOutputForce(controlOutputForce);
    
    String controllerIterationReport = 
    	"====== controllerIterationReport =====" + "\n" +
        "time: " + (new Date(currentTime)) + "\n" +
        "timeElapsedSinceLastUpdate: " + timeElapsedSinceLastUpdate + " seconds" + "\n" +
        "cause: " + options.cause + "\n" +
        "setpoint: " + setpoint.round(2) + " kelvin" + "\n" +
        "temperature: " + temperature.round(2) + " kelvin" + "\n" +
        "controlError: " + controlError + " kelvin" + "\n" +
        "derivativeOfControlError: " + derivativeOfControlError + " kelvin/second" + "\n" +
        "integralOfControlError: " + integralOfControlError + " kelvin*second" + "\n" +
        "controlOutputForce: " + controlOutputForce + "\n" +

        "";
    
    
    sendEvent(name: "controllerIterationReport",   value: controllerIterationReport);

}

//even though the documentation does not mention it, it seems that a device handler, much like a smart app, can have 
// an updated() method, and the platform will cal the updated() method whenever the preferences are changed.
def updated()
{
	log.debug "Updated with settings: ${settings}";
    unschedule(updateController);
    initialize();
}

//even though the documentation does not mention it, it seems that a device handler, much like a smart app, can have 
// an installed() method, and the platform will call the installed() method whenever an instance of the device handler is installed.
def installed() {
	log.debug "installed with settings: ${settings}";
    //set the initial attribute values
    setCoolingSetpoint(80);
    setHeatingSetpoint(60);
    sendEvent(
    	name: "supportedThermostatModes", 
        value: [
            'auto',
            //'eco',
            //'rush hour',
            'cool',
            //'emergency heat',
            'heat',
            'off'
        ]
     );
    setThermostatMode('off');
    initialize();
}



def uninstalled() {
	log.trace "uninstalling"
}


def initialize() {
	// this does not work:
    //subscribe(
    //	getParent().thermometer,
    //    "temperature",
    //    inputHandler
    //)
    log.debug("getParent().thermometer.dump(): " + getParent().thermometer?.dump());
    log.debug("getParent().thermometer.inspect(): " + getParent().thermometer?.inspect());
    //log.debug("getParent().thermometer.class: " + getParent().thermometer.class    );

       
    updateController();
    runEvery1Minute(updateController, [data: [cause: "1 minute interval timer"]]);
}

    


//=========  IMPLEMENTATION OF CAPABAILITIES ================






// commands belonging to the "Thermostat Fan Mode" capability:
def fanOn() {
	log.debug "Executing 'fanOn'"
	// TODO: handle 'fanOn' command
}

def fanAuto() {
	log.debug "Executing 'fanAuto'"
	// TODO: handle 'fanAuto' command
}

def fanCirculate() {
	log.debug "Executing 'fanCirculate'"
	// TODO: handle 'fanCirculate' command
}

def setThermostatFanMode() {
	log.debug "Executing 'setThermostatFanMode'"
	// TODO: handle 'setThermostatFanMode' command
}


// commands belonging to the "Thermostat Heating Setpoint" capability:
def setHeatingSetpoint(x) {
	log.debug "Executing 'setHeatingSetpoint'"
	setSetpoint(x);
}

// commands belonging to the "Thermostat Cooling Setpoint" capability:
def setCoolingSetpoint(x) {
	log.debug "Executing 'setCoolingSetpoint'";
	setSetpoint(x);
    
}


// commands belonging to the "Thermostat Mode" capability:
def off() {
	log.debug "Executing 'off'"
	setThermostatMode('off');
}

def heat() {
	log.debug "Executing 'heat'"
	setThermostatMode('heat');
}

def emergencyHeat() {
	log.debug "Executing 'emergencyHeat'"
	setThermostatMode('emergency heat');
}

def cool() {
	log.debug "Executing 'cool'"
	setThermostatMode('cool');
}

def auto() {
	log.debug "Executing 'auto'"
    setThermostatMode('auto');
}

def setThermostatMode(mode) {
	log.debug "Executing 'setThermostatMode'"
    if(!currentSupportedThermostatModes.contains(mode))
    {
    	log.trace "setThermostatMode() was called with an argument (${mode}) that is not among the supported thermostat modes of this thermostat (${currentSupportedThermostatModes}).  We will not attempt to change the mode.";
    }
    else {
        sendEvent(
            name: "thermostatMode",
            value: mode
        );
        updateController();
    }
}


//// commands belonging to the "Thermostat Schedule" capability:
//def setSchedule() {
//	log.debug "Executing 'setSchedule'"
//	// TODO: handle 'setSchedule' command
//}


//custom commands
def setSetpoint(Number x)
{
	sendEvent(
    	name: "setpoint",
        value: x,
        unit: location.getTemperatureScale()
    );
    
	sendEvent(
    	name:"coolingSetpoint", 
       	value: x, 
        unit: location.getTemperatureScale()
    );
    
    sendEvent(
    	name:"heatingSetpoint", 
       	value: x, 
        unit: location.getTemperatureScale()
    );
    
    updateController();
}

def setControlOutputForce(Number x)
{
	//change the state of heaters and coolers as needed to achieve the specified output force.  (I have not yet developed a physical meaning of the magnitude of the output force.
    if(x > 0 && x.abs() > getPowerOfHeaters().abs())
    {
    	getParent()?.coolers?.off();
    	getParent()?.heaters?.on();
        sendEvent(name: "thermostatOperatingState", value: "heating");
    } else if (x < 0 && x.abs() > getPowerOfCoolers().abs())
    {
    	getParent()?.heaters?.off();
    	getParent()?.coolers?.on();
        sendEvent(name: "thermostatOperatingState", value: "cooling");
    } else
    {
    	getParent()?.heaters?.off();
    	getParent()?.coolers?.off();
        sendEvent(name: "thermostatOperatingState", value: "idle");
    }
    
    sendEvent(
    	name:"controlOutputForce", 
       	value: x, 
        unit: "unitless"
    );
}

//this function, at the moment, only handles temperature
float toSiValue(float value, String unit)
{
	switch(unit) {
    	case "C" :
        	return value + 273.15;
        break;
        case "F" :
        	return (value - 32.0) * 100.0/180.0 + 273.15;
        break;
        case "K" :
        	return value;
        break;
    }
}

def toSiValue(state) //state is expected to be an object returned by calling, for instance, x.currentState("temperature"), where x is a device supporting the "Temperature Measurement" capability.  state is expected to be an object that has a getUnit and a getValue function
{
    
    return state ? toSiValue(state.getFloatValue(), state.getUnit()) : null;
}

def toValueInLocalUnits(float value, String unit)
{
	switch(location.getTemperatureScale()) {
    	case "C" :
        	return toSiValue(value, unit) - 273.15;
        break;
        case "F" :
        	return (toSiValue(value, unit) - 273.15) * 180.0/100.0 + 32.0;      
        break;
        case "K" :
        	return toSiValue(value, unit);
        break;
    }
}
