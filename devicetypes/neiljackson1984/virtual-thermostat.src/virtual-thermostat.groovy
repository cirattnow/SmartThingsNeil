/**
 *  Virtual Thermostat
 *
 *  Copyright 2018 Neil Jackson
 *  This device handler is designed to be created as a child device of the Virtual Thermostat SmartApp.
 */
metadata {
	definition (name: "Virtual Thermostat", namespace: "neiljackson1984", author: "Neil Jackson") {
    	//TAGGING CAPABILITIES: ('tagging' implies that these capabilities have no attributes, and have no commands)
        
        capability "Actuator"  //The "Actuator" capability is simply a marker to inform SmartThings that this device has commands     
        //attributes: (none)
        //commands:  (none)
        
        capability "Sensor"   //The "Sensor" capability is simply a marker to inform SmartThings that this device has attributes     
        //attributes: (none)
        //commands:  (none)
        
        
		capability "Thermostat Cooling Setpoint"
        //attributes: coolingSetpoint
        //commands: setCoolingSetpoint
        
		capability "Thermostat Fan Mode"
        //attributes: thermostatFanMode, supportedThermostatFanModes
        //commands: fanAuto, fanCirculate, fanOn, setThermostatFanMode
        
		capability "Thermostat Heating Setpoint"
        //attributes: heatingSetpoint
        //commands: setHeatingSetpoint
        
		capability "Thermostat Mode"
        //attributes: thermostatMode, supportedThermostatModes
        //commands: auto, cool, emergencyHeat, heat, 'off', setThermostatMode
        
		capability "Thermostat Operating State"
        //attributes: thermostatOperatingState
        //commands: (none)
        
		//  capability "Thermostat Schedule"
        //  //attributes: schedule
        //  //commands: setSchedule
        
        capability "Temperature Measurement"
        //attributes: temperature
        //commands: (none)
        
        capability "Switch"
        //attributes: enum switch
        //commands: on(), off()
        
        capability "Image Capture"
        //attributes: String image
        //commands: take()
        
        attribute ("setpoint", "number");
        command( "setSetpoint", ["number"]);  // I might as well leave this as an internal function since it is not part of a published standard. -- ahah- i must designate it an official command in order to be able to call it as an action from a controlTile.
        
        attribute( "controlError", "number" ); //this will be (actual temperature) - (desired temperature)
        attribute( "integralOfControlError", "number" );
        attribute( "derivativeOfControlError", "number" );
        attribute( "controlOutputForce", "number" );
        attribute( "lastControlUpdateTime", "number" );
        attribute( "controllerIterationReport", "string" );  // a human-readable multi-line report that will be generated by updateController().
        attribute("lastNonOffThermostatMode", "string");
        
        
        //displayableSetpoint and displayableTemperature are hacks to work around the fact that the magic string replacement that the smarthtings ui does in the label of tiles does not provide any way to display the unit of an attribute value.
        // the kludge is to send a "displayableTemperature" event whenever I send a "temperature" event, and same for "displayableSetpoint"
		attribute( "displayableTemperature", "string" ); 
        attribute( "displayableSetpoint", "string" ); 		
		
		//the "controlUpdateRequested" attribute provides a means for code in this device handler to request that the updateController() function be executed.
        // The parent smartapp subscribes to the controlUpdateRequested attribute, and, when it sees a change in the value of the attribute, will call the updateController() method of the child thermostat.
        // the reason that we do it in this roundabout way, rathern than simply calling updateController() directly is to allow any sendEvent() functions to finish propagating, so that the updated attribute values 
        // that the sendEvent() calls caused will be available to updateController() when it runs.
        // the value can be anything as long as it represents a change.
		//attribute( "controlUpdateRequested", "number" );

        
        //these commands exist solely to support the tile-based ui:
        command("switchMode", ["string"]);
        command("increaseSetpoint");
        command("decreaseSetpoint");
        command("resetIntegralButtonHandler");
        command("updateControllerButtonHandler");
        attribute("temperatures", "string");
        //attribute("foo", "number");
}


	simulator {	}

	tiles(scale : 2) {
		multiAttributeTile(name:"thermostatMulti", type:"thermostat", width:6, height:4, canChangeIcon: true) {
			tileAttribute("device.displayableTemperature", key: "PRIMARY_CONTROL") {
				attributeState("arbitraryStringHere", label:'${currentValue}', defaultState: true)
			}
            tileAttribute("device.displayableSetpoint", key: "VALUE_CONTROL") {
				attributeState("VALUE_UP",  action: "increaseSetpoint")
                attributeState("VALUE_DOWN",  action: "decreaseSetpoint")
			}
			tileAttribute("device.thermostatOperatingState", key: "OPERATING_STATE") {
				attributeState("idle", backgroundColor:"#44b621")
				attributeState("heating", backgroundColor:"#ffa81e")
                attributeState("cooling", backgroundColor:"#00A0DC")
			}
			tileAttribute("device.thermostatMode", key: "THERMOSTAT_MODE") {
				attributeState("default", label:'mode: undefined', defaultState: true)
                attributeState("off", label:'mode: ${name}', icon: "http://cdn.device-icons.smartthings.com/thermostat/heating-cooling-off-icn@2x.png")
                attributeState("heat", label:'mode: ${name}', icon: "http://cdn.device-icons.smartthings.com/thermostat/heat-icn@2x.png")
                attributeState("cool", label:'mode: ${name}', icon: 'http://cdn.device-icons.smartthings.com/thermostat/cool-icn@2x.png')
				attributeState("auto", label:'mode: ${name}', icon: "http://cdn.device-icons.smartthings.com/thermostat/auto-icn@2x.png")
			}
            tileAttribute("device.thermostatMode", key: "SECONDARY_CONTROL") {
				attributeState("default", label:'mode: undefined', defaultState: true)
                attributeState("off", label:'mode: ${name}', icon: "http://cdn.device-icons.smartthings.com/thermostat/heating-cooling-off-icn@2x.png")
                attributeState("heat", label:'mode: ${name}', icon: "http://cdn.device-icons.smartthings.com/thermostat/heat-icn@2x.png")
                attributeState("cool", label:'mode: ${name}', icon: 'http://cdn.device-icons.smartthings.com/thermostat/cool-icn@2x.png')
				attributeState("auto", label:'mode: ${name}', icon: "http://cdn.device-icons.smartthings.com/thermostat/auto-icn@2x.png")
			}
            tileAttribute("device.heatingSetpoint", key: "HEATING_SETPOINT") {
            	attributeState("arbitraryStringHere", label:'${currentValue}')
            }
            tileAttribute("device.coolingSetpoint", key: "COOLING_SETPOINT") {
            	attributeState("arbitraryStringHere", label:'${currentValue}')
            }
		}
        
        standardTile("mode", "device.thermostatMode", width: 3, height: 1, decoration: "flat") {
			state "default", defaultState: true, 	/* backgroundColor: "#FFFFFF", */ /*icon: null,																					*/	label:'mode: unknown', 		action:"switchMode", 	nextState:"changingToOff" 			
            state "auto",							/* backgroundColor: "#BF74CC", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/auto-icn@2x.png",					*/	label:'mode: ${name}',		action:"switchMode",	nextState:"changingToCool"			
            state "cool",							/* backgroundColor: "#00A0DC", */ /*icon: 'http://cdn.device-icons.smartthings.com/thermostat/cool-icn@2x.png',					*/	label:'mode: ${name}',		action:"switchMode",	nextState:"changingToHeat"			
            state "heat",							/* backgroundColor: "#E86D13", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/heat-icn@2x.png",					*/	label:'mode: ${name}',		action:"switchMode",	nextState:"changingToOff"			         
            state "off",		        			/* backgroundColor: "#FFFFFF", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/heating-cooling-off-icn@2x.png",	*/	label:'mode: ${name}', 		action:"switchMode", 	nextState:"changingToAuto"
            
            state "changingToAuto",      			/* backgroundColor: "#c7a7cc", */ 																									label:'changing to auto',	/* action:null,	*/		nextState:"changingToAuto"
            state "changingToCool",      			/* backgroundColor: "#9acadc", */ 																									label:'changing to cool',	/* action:null,	*/		nextState:"changingToCool"
            state "changingToHeat",      			/* backgroundColor: "#e8ba99", */ 																									label:'changing to heat',	/* action:null,	*/		nextState:"changingToHeat"
			state "changingToOff",       			/* backgroundColor: "#d6d6d6", */ 																									label:'changing to off',	/* action:null,	*/		nextState:"changingToOff"
            /* 
           
*/            
            
            // useful icon reference: http://htmlpreview.github.io/?https://github.com/krlaframboise/Resources/blob/master/SmartThings-Icons.html
            
          
            //strictly speaking, in the magic string replacement that the platform does in the label text, ${name} is replaced with whatever the first argument to the state() function is, whereas ${currentValue} is replaced with the value of the attribute that this tile represents.
            // magic-string replacement does not occur in the icon  parameter, unfortunately, only in the label parmaeter it seems.
        }
        
        standardTile("offButton", "device.thermostatMode", width: 1, height: 1, decoration: "flat") {
			state "default", defaultState: true, 	/* backgroundColor: "#FFFFFF", */ /*icon: null,																					*/	label:'off()', 		action:"off", 	nextState:"changingToOff" 			
            
            state "auto",							/* backgroundColor: "#BF74CC", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/auto-icn@2x.png",					*/	label:'off()',		action:"off",	nextState:"changingToOff"			
            state "cool",							/* backgroundColor: "#00A0DC", */ /*icon: 'http://cdn.device-icons.smartthings.com/thermostat/cool-icn@2x.png',					*/	label:'off()',		action:"off",	nextState:"changingToOff"			
            state "heat",							/* backgroundColor: "#E86D13", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/heat-icn@2x.png",					*/	label:'off()',		action:"off",	nextState:"changingToOff"			         
            state "off",		        			/* backgroundColor: "#FFFFFF", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/heating-cooling-off-icn@2x.png",	*/	label:'off()', 		action:"off" 	/* nextState:"changingToOff"*/
            
            state "changingToOff",      				/* backgroundColor: "#c7a7cc", */ 																								 label:'changing mode to off',	action:null,			nextState:"changingToOff"
        }
        
        standardTile("autoButton", "device.thermostatMode", width: 1, height: 1, decoration: "flat") {
			state "default", defaultState: true, 	/* backgroundColor: "#FFFFFF", */ /*icon: null,																					*/	label:'auto()', 		action:"auto", 	nextState:"changingToOff" 			
            
            state "auto",							/* backgroundColor: "#BF74CC", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/auto-icn@2x.png",					*/	label:'auto()',		action:"auto"	/* nextState:"changingToAuto"	*/		
            state "cool",							/* backgroundColor: "#00A0DC", */ /*icon: 'http://cdn.device-icons.smartthings.com/thermostat/cool-icn@2x.png',					*/	label:'auto()',		action:"auto",	nextState:"changingToAuto"			
            state "heat",							/* backgroundColor: "#E86D13", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/heat-icn@2x.png",					*/	label:'auto()',		action:"auto",	nextState:"changingToAuto"			         
            state "off",		        			/* backgroundColor: "#FFFFFF", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/heating-cooling-off-icn@2x.png",	*/	label:'auto()', 		action:"auto", 	nextState:"changingToAuto"
            
            state "changingToAuto",      				/* backgroundColor: "#c7a7cc", */ 																								 label:'changing mode to auto',	action:null,			nextState:"changingToAuto"
        }
        
        standardTile("onButton", "device.lastNonOffThermostatMode", width: 1, height: 1, decoration: "flat") {
			state "default", defaultState: true, 	/* backgroundColor: "#FFFFFF", */ /*icon: null,																					*/	label:'on() (${currentValue})', 		action:"on" 		    
        }
        
        valueTile("temperature", "device.displayableTemperature", width: 3, height: 1, decoration: "flat"){
        	state "default", label:'temperature: ${currentValue}', defaultState:true
        }
        valueTile("temperatures", "device.temperatures", width: 3, height: 1, decoration: "flat"){
        	state "default", label:'temperatures: ${currentValue}', defaultState:true
        }
        
        valueTile("setpoint", "device.displayableSetpoint", width: 3, height: 1, decoration: "flat"){
        	state "default", label:'setpoint: ${currentValue}', defaultState:true
            
            //state "default", label:'setpoint:\u00A078.0\u00A0F', defaultState:true
			// the text flowing for labels does not ditinguish between regular and nonbreaking space.
        } 
        standardTile("thermostatOperatingState", "device.thermostatOperatingState", width: 3, height: 1, decoration: "flat"){
        	state "thermostatOperatingState", label:'${name}: ${currentValue}', defaultState: true
        }
        
        //	valueTile("controlError", "device.controlError", width: 2, height: 2, decoration: "flat"){
        //		state "default", label:'controlError: ${currentValue}', unit: "ahoy", defaultState:true
        //	}      
        //	valueTile("integralOfControlError", "device.integralOfControlError", width: 2, height: 2, decoration: "flat"){
        //		state "default", label:'integralOfControlError: ${currentValue}', unit: "ahoy", defaultState:true
        //	}       
        //	valueTile("derivativeOfControlError", "device.derivativeOfControlError", width: 2, height: 2, decoration: "flat"){
        //		state "default", label:'derivativeOfControlError: ${currentValue}', unit: "ahoy", defaultState:true
        //	}        
        //	valueTile("controlOutputForce", "device.controlOutputForce", width: 2, height: 2, decoration: "flat"){
        //		state "default", label:'controlOutputForce: ${currentValue}', unit: "ahoy", defaultState:true
        //	}        
        //	valueTile("lastControlUpdateTime", "device.lastControlUpdateTime", width: 2, height: 2, decoration: "flat"){
        //		state "default", label:'lastControlUpdateTime: ${currentValue}', unit: "ahoy", defaultState:true
        //	} 
        
        standardTile("updateControllerButton", "whatever", width: 1, height: 1, decoration: "flat"){
        	state "default", label:'updateController()', unit: "ahoy", defaultState:true, action:"updateControllerButtonHandler"
        }        
        standardTile("resetIntegralButton", "whatever", width: 1, height: 1, decoration: "flat"){
        	state "default", label:'resetIntegral()', unit: "ahoy", defaultState:true, action:"resetIntegralButtonHandler"
        }        
        standardTile("controllerIterationReport", "device.controllerIterationReport", width: 6, height: 6, decoration: "flat", alignment: 'left', align: 'left', style: 'text-align:left'){
        	state "default", label:'${currentValue}', defaultState:true //action:"resetIntegral"
        }
        
        standardTile("take", "device.image", width: 1, height: 1, canChangeIcon: false, inactiveLabel: true, canChangeBackground: false) {
            state "take", label: "Take", action: "Image Capture.take", icon: "st.camera.dropcam", backgroundColor: "#FFFFFF", nextState:"taking"
            state "taking", label:'Taking', action: "", icon: "st.camera.dropcam", backgroundColor: "#00A0DC"
            state "image", label: "Take", action: "Image Capture.take", icon: "st.camera.dropcam", backgroundColor: "#FFFFFF", nextState:"taking"
    	}

        
        carouselTile("performanceGraph", "device.image", width: 12, height: 9) {
        	state "image", label:"ahoy", action:"Image Capture.take", defaultState:true
        }
        
       ////  controlTile(
		////  	"setpointControlTile",            // String tileName -- a unique name, to be used as an argument to the main() or details() function below
		////  	"device.setpoint",                // String attributeName 
		////  	"control",                        // String controlType  --  expected to be one of {"slider", "control"}
       ////      width:                     3,   // Integer	controls how wide the tile is. Default is 1.
       ////      height:                    3,   // Integer	controls how tall this tile is. Default is 1.
       ////      canChangeIcon:         false,   // Boolean	true to allow the user to pick their own icon. Defaults to false.
       ////      canChangeBackground:   false,   // Boolean	true to allow a user to choose their own background image for the tile. Defaults to false.
       ////      decoration:           'flat',   // String	specify "flat" for the tile to render without a ring.
       ////      //range:                   null,   // String	used to specify a custom range. In the form of "(<lower bound>..<upper bound>)"
       ////      inactiveLabel:         false    //undocumented options
       ////  ){
       ////  	state(
       ////                                  "setpoint",    // String stateName - the name of the attribute value for which to display this state for.
       ////          action:           'setSetpoint',    // String	the action to take when this tile is pressed. The form is <capabilityReference>.<command>.
       ////          //backgroundColor:           null,    // String	a hexadecimal color code to use for the background color. This has no effect if the tile has decoration: “flat”.
       ////          //backgroundColors:          null,    // 	String	specify a list of maps of attribute values and colors. The mobile app will match and interpolate between these entries to select a color based on the value of the attribute.
       ////          defaultState:              true,    // 	Boolean	specify true if this state should be the active state displayed for this tile.
       ////          //icon:                      null,    // 	String	the identifier of the icon to use for this state.
       ////         label: 'ahoy'                       // 	String	the label for this state. 
       ////     )
       ////     state("VALUE_UP", label: '${currentValue.round(2)}', action: "increaseSetpoint")
       ////     state("VALUE_DOWN", label: '${currentValue.toString().toFloat().round(2)}', action: "decreaseSetpoint")
       ////  }
        

        main ("thermostatMulti")
        details(
        	[
            	"thermostatMulti", 
                "mode",
                "thermostatOperatingState",
                "temperature",
                //"temperatures",
                "setpoint", 
                
 
                
                "offButton",
                "autoButton",
                "onButton",
                "updateControllerButton",
                "resetIntegralButton",
                     "take",
                "performanceGraph",
                "controllerIterationReport"
             
              
            ]
        )
    }
    
    preferences{
    	section(){
            paragraph("the controller will wait this long after changing the state of a heater or cooler before changing the state again. (prevents rapid cycling)");
            //Remember, Multiple page preferences and dynamic preferences pages are not supported in Device Handlers (only in SmartApps).
            // the smartapps preferences pages are much more flexible than the device preferences page, so perhaps we ought to put all preference entry there.
            input( 
                name: "holdoffDuration",
                title: "holdoffDuration (seconds): \nthe controller will wait this long after changing the state of a heater or cooler before changing the state again. (prevents rapid cycling)", 
                type: "number",
                description: "the controller will wait this long after changing the state of a heater or cooler before changing the state again. (prevents rapid cycling)", 
                required: false, 
                defaultValue: getSetting("holdoffDuration")
            );
            
            input( 
                name: "pCoefficient",
                title: "pCoefficient ([output force]/Kelvin): \nThis is the p coefficient of the PID controller.", 
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getSetting("pCoefficient")
            );
            
            input( 
                name: "iCoefficient",
                title: "iCoefficient ([output force]/(Kelvin * seconds): \nThis is the i coefficient of the PID controller.", 
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getSetting("iCoefficient")
            );
            
            input( 
                name: "dCoefficient",
                title: "dCoefficient ([output force]/(Kelvin/seconds): \nThis is the d coefficient of the PID controller. (not yet supported - this value will be ignored.)", 
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getSetting("dCoefficient")
            );
            
            input( 
                name: "powerOfHeaters",
                title: "powerOfHeaters ([output force]): \nThis is an input that allows you to tell the controller what (magnitude of) the power of the heaters (collectively) is.  " + 
                	"Because the ultimate output of the controller is just one of the the three values {heat, cool, or off}, the meaning of the powerOfHeaters setting is not " + 
                    "well-defined in physical terms.  The effect of powerOfHeaters and powerOfCoolers is to set the relative size of the off-to-heat and off-to-cool deadbands." +
                    "the algorithm will attend to only the absolute value, and not the sign, of this number."
                    ,
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getSetting("powerOfHeaters")
            );
            
            input( 
                name: "powerOfCoolers",
                title: "powerOfCoolers([output force]): \nAnalogous to powerOfHeaters, decribed above.", 
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getSetting("powerOfCoolers")
            );
            
        }
    }
}


//=============functions that serve as click handlers for the tile-based ui:
def switchMode(arg)
{
 	log.debug "switchMode was called " + "with arg: " + arg;
    switch(device.currentState("thermostatMode")?.getStringValue())
    {
    	case 'auto': setThermostatMode('cool'); break;
        case 'cool': setThermostatMode('heat'); break;
        case 'heat': setThermostatMode('off'); break;
        case 'off': setThermostatMode('auto'); break;
        //case 'emergency heat': 	...
        //case 'eco':				...
        //case 'rush hour':			...
        default: setThermostatMode('off'); break;
    }
}

def increaseSetpoint()
{
	log.debug "increaseSetpoint was called "//with arg: " + arg;
    nudgeSetpoint(+0.1);
}

def decreaseSetpoint()
{
	log.debug "decreaseSetpoint was called"// with arg: " + arg;
    nudgeSetpoint(-0.1);
    
}

def nudgeSetpoint(x)
{
	setSetpoint((device.currentState("setpoint").getFloatValue() + x).round(2));
}

def resetIntegralButtonHandler()
{
	resetIntegral();
    updateController(cause:"resetIntegral() button was clicked.");
}

def updateControllerButtonHandler()
{
	updateController(cause:"updateController() button was clicked.");
}

//def requestControllerUpdate(Map data=[:])
//{
//	sendEvent(name: 'controlUpdateRequested', value: (new Date()).getTime(), data:data);
//}

def resetIntegral()
{
	sendEvent(name: "integralOfControlError",   value: 0.0, unit: "K*s");
}

//===== PREFERENCE GETTERS
//we need preference getters, instead of simply reading the preference values,
// because it can happen that this device is running without the user ever having clicked through the preferences page.
// this is most likely in the case where this device is created as a child device of some other device or smartapp.  
// If the user hasn't clicked through the preferences pages, then the preference values will all be null, and we need to have default values.functions that serve as getters for the preferences, which are necessary to provide the default values in case the user has never clicked through the preferences page (and therefore the settings object isn't populated with all  of the keys declared in the preferences metadata above)
def getDefaultSettings(){
	return \
    	[
        	'holdoffDuration'  : 113,
            'pCoefficient'     : -1,
            'iCoefficient'     : -0.000001,
            'dCoefficient'     : 0,
            'powerOfHeaters'   : 1,
            'powerOfCoolers'   : 1
        ];
}

def getSetting(nameOfSetting){
	return settings?.containsKey(nameOfSetting) ? settings[nameOfSetting] : getDefaultSettings()[nameOfSetting];
    //return settings[nameOfSetting] ?: getDefaultSettings()[nameOfSetting];
}

// parse events into attributes
def parse(String description) {
	log.debug "Parsing '${description}'"
	// TODO: handle 'coolingSetpoint' attribute
	// TODO: handle 'thermostatFanMode' attribute
	// TODO: handle 'supportedThermostatFanModes' attribute
	// TODO: handle 'heatingSetpoint' attribute
	// TODO: handle 'thermostatMode' attribute
	// TODO: handle 'supportedThermostatModes' attribute
	// TODO: handle 'thermostatOperatingState' attribute
	// TODO: handle 'schedule' attribute
	// TODO: handle 'thermostatSetpoint' attribute
}

def setTemperature(float value, String unit){
	//we prefer not to do a pass through toSiValue to avoid creating a number with a lot of digits after the decimal point, which there is no good way to round at the time of display, and so looks ugly in the ui.
	float valueInLocalUnits = (unit == location.getTemperatureScale()   ?    value :  toValueInLocalUnits(toSiValue(value, unit), "K"));   
    sendEvent(
    name: "temperature",  
        value: valueInLocalUnits, 
        unit: location.getTemperatureScale()
    );
    
    sendEvent(
        name: "displayableTemperature", 
        value: valueInLocalUnits + " \u00b0" + location.getTemperatureScale()
    )
    
    
    // I am passing the new temperature to updateController as an argument rather than letting updateController() read the latest state because I suspect that the above sendEvent() will not have taken effect fully when I call updateController() immediately below.  //TO DO: use device.state to overcome this problem.
    //state.temperature = toSiValue(value, unit);
    updateController(cause: "setTemperature");
}

def setTemperature(float value){
	setTemperature(value, location.getTemperatureScale());
}

def setTemperature(List states){
	log.debug("states: " + states)
    float valueInLocalUnits = states.sum{it.getUnit() == location.getTemperatureScale()   ?    it.getFloatValue() :  toValueInLocalUnits(toSiValue(it.getValue(), it.getUnit()), "K") }/states.size();
    sendEvent(name:"temperatures", value: states.collect{[it.getDevice().name, it.getValue(), it.getUnit()]})
    
    setTemperature(valueInLocalUnits);
}

def setTemperature(state){
	setTemperature(state.getFloatValue(), state.getUnit());
}

// the parent SmartApp will invoke this method to tell the virtual thermostat to take a look at the thermometer's current reading and
// take action as needed.  This is where the meat of the control algorithm is.
def updateController(Map options=[:]){
	//the SmartThings documentation (see https://docs.smartthings.com/en/latest/cloud-and-lan-connected-device-types-developers-guide/building-lan-connected-device-types/building-the-service-manager.html?highlight=parent#best-practices)
    // mentions that the best practice is to not have a child device make calls to the parent smartapp, but instead have the
    // parent smart app pass all necessary information to the methods of the child device as arguments.
    // I am intentionally violating that rule here to see what happens and because it seems cleaner to me
    // to have the child device retrieve the temperature from the parent.
    // Then again, I would intuitively think that a device ought to be able to subscribe to events from other devices (which is not the way it really is)
    // so maybe my mental model of a device is a bit different than that intended by the SmartThings architects.
	// update the temperature attribute of this virtual thermostat device to match the temperature attribute of the thermometer of the parent smartApp.
    // (The documentation does not even mention that a device has a getParent() method. )
    // there is a lot of overlap between the concept of SmartApp and the concept of Device.
    
    /*
    	I incorrectly assumed that the attribute value, as retrieved by methods such as device.currentValue(<attributeName>) and device.currentState(<attributeName>).getValue(),
        would not reflect any calls to SendEvent(name: <attributeName>, ...) that had occured in the current execution of the device handler.
        In order to work around this assumed problem, after updating an attribute value, I would trigger the updateController method to be called by a subscription handler in the parent SmartApp.
        
        It turns out that this is unncessary, because an attribute value updated with sendEvent() is immediately available from device.currentValue() and device.currentState().
    */
    log.debug("updateController(" +  options +  ") was called.");
    long  time 								= (new Date()).getTime();
    float temperature 						= device.currentState('temperature') ? toSiValue(device.currentState('temperature')) : 0; 
    float setpoint 							= toSiValue(device.currentState('setpoint')); 
    long  lastControlUpdateTime 			= device.currentState('lastControlUpdateTime')?.getLongValue() ?: time;
	float timeElapsedSinceLastUpdate  		= ((float)(time - lastControlUpdateTime))/1000.0;
    float lastDerivativeOfControlError 		= device.currentState('derivativeOfControlError')?.getFloatValue()     ?: 0;
    float lastControlError                  = device.currentState('controlError')?.getFloatValue()                ?: 0;                                  
    float lastIntegralOfControlError        = device.currentState('integralOfControlError')?.getFloatValue()       ?: 0;                 
    float lastControlOutputForce            = device.currentState('controlOutputForce')?.getFloatValue()       ?: 0;  
    float controlError 						= temperature - setpoint;
    float derivativeOfControlError;
    float integralOfControlError;
    float controlOutputForce;
    
    
   //compute the derivative of the error  
   if(time == lastControlUpdateTime) //should we also check whether currentTime < lastControlUpdateTime ? Would that ever happen?
   {
   		derivativeOfControlError = lastDerivativeOfControlError;
   } else {
   		derivativeOfControlError = (controlError - lastControlError) / timeElapsedSinceLastUpdate;
   }
   
   //compute the integral of the control error
   integralOfControlError = lastIntegralOfControlError + lastControlError * timeElapsedSinceLastUpdate;

   
   //compute controlOutputForce
   controlOutputForce = 
   		getSetting('pCoefficient') * controlError + getSetting('iCoefficient') * integralOfControlError + getSetting('dCoefficient') * derivativeOfControlError;
   //override controlOutputForce to zero if the mode is off
   if(state.thermostatMode == 'off'){controlOutputForce = 0;}

    //store the necessary state information to be used on the next pass (and for anyone who happens to subscribe to these attributes)
    sendEvent(name: "lastControlUpdateTime",    value: time);
    sendEvent(name: "controlError",             value: controlError, unit: "K"); //to do : express the controlError in the units specified by the location temperature units preference.
    sendEvent(name: "derivativeOfControlError", value: derivativeOfControlError, unit: "K/s");
    sendEvent(name: "integralOfControlError",   value: integralOfControlError, unit: "K*s");
    setControlOutputForce(controlOutputForce);

    def controlUpdateData = 
        [
            'time'                           : time,
            'temperature'                    : temperature,
            'setpoint'                       : setpoint,
            'lastControlUpdateTime'          : lastControlUpdateTime,
            'timeElapsedSinceLastUpdate'     : timeElapsedSinceLastUpdate,
            'lastDerivativeOfControlError'   : lastDerivativeOfControlError,
            'lastControlError'               : lastControlError,
            'lastIntegralOfControlError'     : lastIntegralOfControlError,
            'lastControlOutputForce'         : lastControlOutputForce,
            'controlError'                   : controlError,
            'derivativeOfControlError'       : derivativeOfControlError,
            'integralOfControlError'         : integralOfControlError,
            'controlOutputForce'             : controlOutputForce
        ];

	//def subsequentValuesOfFoo = [];
    //def foo = 0;
    //
    //sendEvent(name: "foo", value: foo++);
	//subsequentValuesOfFoo << device.currentValue("foo");
    //
    //sendEvent(name: "foo", value: foo++);
	//subsequentValuesOfFoo << device.currentState("foo").value;
    //
    //sendEvent(name: "foo", value: foo++);
    
    def newLine = "\n";
    String controllerIterationReport = 
		"====== controllerIterationReport ====="                                                                  + newLine +
        "time: "                        + (new Date(time))                                                        + newLine +
        "timeElapsedSinceLastUpdate: "  + timeElapsedSinceLastUpdate + " seconds"                                        + newLine +
        "cause: "                       + options.cause                                                                  + newLine +
        "setpoint: "                    + setpoint.round(2) + " kelvin"                                                  + newLine +
        "temperature: "                 + temperature.round(2) + " kelvin"                                               + newLine +
        "temperatures: "                + device.currentValue("temperatures")                                            + newLine +
        "controlError: "                + controlError + " kelvin"                                                       + newLine +
        "derivativeOfControlError: "    + derivativeOfControlError + " kelvin/second"                                    + newLine +
        "integralOfControlError: "      + integralOfControlError + " kelvin*second"                                      + newLine +
        "controlOutputForce: "          + controlOutputForce                                                             + newLine +
        "status of heaters:"                                                                                             + newLine +
        	getParent().heaters.inject(""){result, item -> result + "\t" + item + ": " + item.currentSwitch + newLine}   + newLine +
        "status of coolers:"                                                                                             + newLine +
        	getParent().coolers.inject(""){result, item -> result + "\t" + item + ": " + item.currentSwitch + newLine}   + newLine +
        //"subsequentValuesOfFoo: "       + subsequentValuesOfFoo                                                          + newLine +
        "";
    
    sendEvent(name: "controllerIterationReport",   value: controllerIterationReport, data:state.controlUpdateData);
    if(options.cause == "1 minute interval timer")
    {
    	take();
    }
}


//===== LIFECYCLE METHODS ===============
//even though the documentation does not mention it, it seems that a device handler, much like a smart app, can have 
// an updated() method, and the platform will cal the updated() method whenever the preferences are changed.
def updated(){
	log.debug "Updated with settings: ${settings}";
    unschedule(updateController);
    //unsubscribe();
    initialize();
}

//even though the documentation does not mention it, it seems that a device handler, much like a smart app, can have 
// an installed() method, and the platform will call the installed() method whenever an instance of the device handler is installed.
def installed() {
	log.debug "installed with settings: ${settings}";
    //set the initial attribute values
    setSetpoint(toValueInLocalUnits(toSiValue(70, 'F'), 'K'));
   
    
    initialize();
    setThermostatMode('off');
}

def uninstalled() {
	log.trace "uninstalling"
}


def initialize() {
	// this does not work:
    //subscribe(
    //	getParent().thermometer,
    //    "temperature",
    //    inputHandler
    //)
    //log.debug("getParent().thermometer.dump(): " + getParent().thermometer?.dump());
    //log.debug("getParent().thermometer.inspect(): " + getParent().thermometer?.inspect());
    //log.debug("getParent().thermometer.class: " + getParent().thermometer.class    );
	sendEvent(
    	name: "supportedThermostatModes", 
        value: [
            'auto',
            //'eco',
            //'rush hour',
            'cool',
            //'emergency heat',
            'heat',
            'off'
        ]
     );
     
     //log.debug("device: " + device);
     //log.debug("device.getId(): " + device.getId());
    // log.debug("getGroup(): " + getGroup());
     //log.debug("getParent().getChildThermostat(): " + getParent().getChildThermostat());
     //log.debug("getParent().getChildThermostat(): " + groovy.json.JsonOutput.toJson(getParent().getChildThermostat()));
     //log.debug("getParent().getChildThermostat(): " + groovy.json.JsonOutput.toJson(getParent()));
    //log.debug("getParent().getChildThermostat().inspect(): " + groovy.json.JsonOutput.toJson(getParent().getChildThermostat().inspect()));
    //subscribe(getParent().getChildThermostat(), "temperature", doNothing);   
    
    updateController(cause: "thermostat initialized");
    runEvery1Minute(updateController, [data: [cause: "1 minute interval timer"]]);
}

def doNothing(){
	log.debug "doNothing() was called"
}


//=========  IMPLEMENTATION OF CAPABAILITIES ================


// commands belonging to the "Thermostat Fan Mode" capability:
def fanOn() {
	log.debug "Executing 'fanOn'"
	// TODO: handle 'fanOn' command
}

def fanAuto() {
	log.debug "Executing 'fanAuto'"
	// TODO: handle 'fanAuto' command
}

def fanCirculate() {
	log.debug "Executing 'fanCirculate'"
	// TODO: handle 'fanCirculate' command
}

def setThermostatFanMode() {
	log.debug "Executing 'setThermostatFanMode'"
	// TODO: handle 'setThermostatFanMode' command
}

// commands belonging to the "Thermostat Heating Setpoint" capability:
def setHeatingSetpoint(x) {
	log.debug "setHeatingSetpoint(${x}) was called";
	setSetpoint(x);
}

// commands belonging to the "Thermostat Cooling Setpoint" capability:
def setCoolingSetpoint(x) {
	log.debug "setCoolingSetpoint(${x}) was called";
	setSetpoint(x);
    
}

// commands belonging to the "Thermostat Mode" capability:
def off() {  // this command also belongs to the switch capability
	log.debug "Executing 'off'"
	setThermostatMode('off');
}

def heat() {
	log.debug "Executing 'heat'"
	setThermostatMode('heat');
}

def emergencyHeat() {
	log.debug "Executing 'emergencyHeat'"
	setThermostatMode('emergency heat');
}

def cool() {
	log.debug "Executing 'cool'"
	setThermostatMode('cool');
}

def auto() {
	log.debug "Executing 'auto'"
    setThermostatMode('auto');
}

def setThermostatMode(mode) {
	log.debug "Executing 'setThermostatMode'"
    //log.debug device.currentValue("supportedThermostatModes").dump()
    if(!device.currentValue("supportedThermostatModes").contains(mode))
    {
    	log.trace "setThermostatMode() was called with an argument (${mode}) that is not among the supported thermostat modes of this thermostat (${currentSupportedThermostatModes}).  We will not attempt to change the mode.";
    }
    else 
    {
        if(mode != 'off')
        {
        	sendEvent(name: "lastNonOffThermostatMode", value: mode);
        }        
        def oldMode = device.currentValue("thermostatMode");
        sendEvent(
            name: "thermostatMode",
            value: mode
        );
        
        sendEvent(
        	name: "switch",
            value: (mode == 'off' ? 'off' : 'on')
        )
        
        if(oldMode != mode){        resetIntegral();}
        updateController('cause':"thermostatMode change from ${oldMode} to ${mode}.");
    }
}

//commands belonging to the "Switch" capabiLity
def on()
{
   /// change the mode to the last non-off mode value auto();
   setThermostatMode(device.currentValue("lastNonOffThermostatMode") ?: 'auto');
}

//// commands belonging to the "Thermostat Schedule" capability:
//def setSchedule() {
//	log.debug "Executing 'setSchedule'"
//	// TODO: handle 'setSchedule' command
//}

//this function returns the query map suitable for passing as the query parameter to httpGet when calling the Google image chart service
def lineChartQuery(arg){
	//arg is a list of elements of the form [name: String name of series, color: ..., data: [[x0,y0] , [x1,y1], ...]map whose keys are strings - names of the series, and whose values are lists of two-element lists of numbers - cartesian coordinates.
    def query = [:];
    query['cht'] = 'lxy'; //chart type is lineXY
   // query['chds'] = //'a'; //auto scaling (documentation suggest that this only has effect if the data is in the "text" format.
    query['chco'] = "FF0000,00FF00,0000FF";
    query['chdl'] =  arg.collect{it['name'] ?: ''}.join('|');
    def rangeX = {x->[x.min(),x.max()]}(arg.sum{it['data'].collect{it[0]}});
    def rangeY = {x->[x.min(),x.max()]}(arg.sum{it['data'].collect{it[1]}});
     query['chds'] = arg.sum{rangeX + rangeY}.join(',');
    query['chd'] = 
    	't:' + 
        arg.collect{
        	it ->
        	[0,1].collect{ 
            	i ->
            	it.data.collect{
                	v -> v[i]                    
                }.join(',')
            }.join('|')
        }.join('|');
     
         query['chtt'] = new Date(); //chart title
    return query;
}

//commands belonging to the "Image Capture" capability
// see https://docs.smartthings.com/en/latest/cloud-and-lan-connected-device-types-developers-guide/working-with-images.html
def take()
{
	log.debug "take() was called."
    def graphDuration = 60 * 60 * 5; //in seconds
    def currentTime = now();
  def params = [
        uri: 'https://chart.googleapis.com', 
        path: '/chart',
        query: [
         	"chs": "${(int) 158*2}x${(int) 158*1.5}",    //chart size
            "chof": "png"                             //chart output format
          ] + 
          lineChartQuery(
          	[
                [
                'name': 'setpoint',
                'data': 
                    device.statesSince("setpoint",new Date(currentTime-graphDuration*1000)).collect{ theState ->
                    	[
                        	theState.getDate().getTime() - currentTime,
                            theState.getFloatValue()
                        ]
                    }
                ],
                [
                'name': 'temperature',
                'data':  device.statesSince("temperature",new Date(currentTime-graphDuration*1000)).collect{ theState ->
                    	[
                        	theState.getDate().getTime() - currentTime,
                            theState.getFloatValue()
                        ]
                    }
                ]
            ]
          )
    ];
    
    def url = params.uri + params.path + '?' + params.query.collect{k,v -> "${k}=${v}"}.join("&");
    log.debug "url: " + url;
    
    //https://avatars1.githubusercontent.com/u/24784194?s=400&v=4
    try {
        httpGet(params) { response ->
            // we expect a content type of "image/jpeg" from the third party in this case
            if (response.status == 200 && response.headers.'Content-Type'.contains("image/png")) {
                def imageBytes = response.data
                if (imageBytes) {
                    def name = java.util.UUID.randomUUID().toString().replaceAll('-','')
                    try {
                        storeImage(name, imageBytes)
                        log.debug("stored image ${name} succesfully.")
                        // log.debug 'response.getHeaders(): ' + (response.getHeaders().collect(it.toString()).join(" "));
                        //log.debug 'response.getHeaders(): ' + response.responseBase.getAllHeaders();
                        //log.debug response.getParams()[":path"]
                          log.debug "response headers: "+ response.headers.collect {"${it.name} : ${it.value}"}.join(',');
                           //log.debug "response.params: " + response.params
                    } catch (e) {
                        log.error "Error storing image ${name}: ${e}"
                    }
                }
            } else {
                log.error "Image response not successful or not a jpeg response"
            }
        }
    } catch (err) {
        log.debug "Error making request: $err"
    }
}


//custom commands
def setSetpoint(Number x)
{
	log.debug "setSetpoint(${x}) was called";
    
    if(device.currentValue("setpoint") != x) //we probably should do some sort of tolerant equality checkings, so that we only reset the integral when the setpoint is changing by some large amount.  Ideally, this compensation should be done in updateController()
    {
    	resetIntegral();
    }
  
	sendEvent(
    	name: "setpoint",
        value: x,
        unit: location.getTemperatureScale()
    );
    
    //displayableSetpoint is a hack to work around the fact that the magic string replacement that the smarthtings ui does in the label of tiles does not provide any way to disploay the unit of an attribute value.
    sendEvent(
    	name: "displayableSetpoint",
        value: x + " \u00b0" + location.getTemperatureScale()
    );
    
	sendEvent(
    	name:"coolingSetpoint", 
       	value: x, 
        unit: location.getTemperatureScale()
    );
    
    sendEvent(
    	name:"heatingSetpoint", 
       	value: x, 
        unit: location.getTemperatureScale()
    );
    updateController('cause' : "setSetpoint");
}

def setControlOutputForce(Number x)
{
	//change the state of heaters and coolers as needed to achieve the specified output force.  (I have not yet developed a physical meaning of the magnitude of the output force.
    if(x > 0 && x.abs() > getSetting('powerOfHeaters').abs() && ['auto','heat'].contains(device.currentValue('thermostatMode')))
    {
		turnOffCoolers();
        turnOnHeaters();
        sendEvent(name: "thermostatOperatingState", value: "heating");
    } else if (x < 0 && x.abs() > getSetting('powerOfCoolers').abs() && ['auto','cool'].contains(device.currentValue('thermostatMode')))
    {
    	turnOffHeaters();
    	turnOnCoolers();
        sendEvent(name: "thermostatOperatingState", value: "cooling");
    } else
    {
    	log.debug "device.getId: " + device.getId();
        turnOffHeaters();
        turnOffCoolers();
        sendEvent(name: "thermostatOperatingState", value: "idle");
    }
    
    sendEvent(
    	name:"controlOutputForce", 
       	value: x, 
        unit: "unitless"
    );
}

def turnOnHeaters()
{
    getParent()?.settings?.heaters?.each{
        if(it.hasCapability("Thermostat") && it.currentValue("supportedThermostatModes").contains('heat'))
        {
            it.setThermostatMode('heat');
            //log.debug "it.currentValue(\"heatingSetpointRange\"): " + it.currentValue("heatingSetpointRange")
            //log.debug "it.currentValue(\"heatingSetpointRange\")?.values(): " + it.currentValue("heatingSetpointRange")?.values()
            //log.debug "it.currentValue(\"heatingSetpointRange\")?.values().max(): " + it.currentValue("heatingSetpointRange")?.values().max()
            it.setHeatingSetpoint(
                it.currentValue("heatingSetpointRange")?.values()?.max() ?: 99
            );
        } else 
        {
            if(it.hasCapability("Thermostat Mode") && it.currentValue("supportedThermostatModes")?.contains('heat')){it.setThermostatMode('heat');}
            if(it.hasCapability("Thermostat Heating Setpoint")){it.setHeatingSetpoint(99);}
            if(it.hasCapability("Switch Level")){it.setLevel(100);}
            if(it.hasCapability("Switch")){it.on();}
        }
    };
}

def turnOffHeaters()
{
	getParent()?.settings?.heaters?.each{
        if(it.hasCapability("Thermostat") && it.currentValue("supportedThermostatModes").contains('off'))
        {
            it.setHeatingSetpoint(
                it.currentValue("heatingSetpointRange")?.values()?.min() ?: 0
            );
            it.off();
        } else 
        {
            if(it.hasCapability("Thermostat Heating Setpoint")){it.setHeatingSetpoint(0);}
            if(it.hasCapability("Thermostat Cooling Setpoint")){it.setCoolingSetpoint(99);}
            if(it.hasCapability("Thermostat Mode") && it.currentValue("supportedThermostatModes")?.contains('off')){it.setThermostatMode('off');}
            if(it.hasCapability("Switch Level")){it.setLevel(0);}
            if(it.hasCapability("Switch")){it.off();}
        }
    };
}

def turnOnCoolers()
{
    getParent()?.settings?.coolers?.each{
        if(it.hasCapability("Thermostat") && it.currentValue("supportedThermostatModes").contains('cool'))
        {
            it.setThermostatMode('cool');
            it.setCoolingSetpoint(
                it.currentValue("coolingSetpointRange")?.values()?.min() ?: 0
            );
        } else 
        {
            if(it.hasCapability("Thermostat Mode") && it.currentValue("supportedThermostatModes")?.contains('cool')){it.setThermostatMode('cool');}
            if(it.hasCapability("Thermostat Cooling Setpoint")){it.setCoolingSetpoint(0);}
            if(it.hasCapability("Switch Level")){it.setLevel(100);}
            if(it.hasCapability("Switch")){it.on();}
        }
    };
}

def turnOffCoolers()
{
    getParent()?.settings?.coolers?.each{
        if(it.hasCapability("Thermostat") && it.currentValue("supportedThermostatModes").contains('off'))
        {
            it.setCoolingSetpoint(
                it.currentValue("coolingSetpointRange")?.values()?.max() ?: 99
            );
            it.off();
        } else 
        {
            if(it.hasCapability("Thermostat Heating Setpoint")){it.setHeatingSetpoint(0);}
            if(it.hasCapability("Thermostat Cooling Setpoint")){it.setCoolingSetpoint(99);}
            if(it.hasCapability("Thermostat Mode") && it.currentValue("supportedThermostatModes")?.contains('off')){it.setThermostatMode('off');}
            if(it.hasCapability("Switch Level")){it.setLevel(0);}
            if(it.hasCapability("Switch")){it.off();}
        }
    };
} 	

//this function, at the moment, only handles temperature
float toSiValue(float value, String unit)
{
	switch(unit) {
    	case "C" :
        	return value + 273.15;
        break;
        case "F" :
        	return (value - 32.0) * 100.0/180.0 + 273.15;
        break;
        case "K" :
        	return value;
        break;
    }
}

def toSiValue(state) //state is expected to be an object returned by calling, for instance, x.currentState("temperature"), where x is a device supporting the "Temperature Measurement" capability.  state is expected to be an object that has a getUnit and a getValue function
{
    return state ? toSiValue(state.getFloatValue(), state.getUnit()) : null;
}

def toValueInLocalUnits(float value, String unit)
{
	switch(location.getTemperatureScale()) {
    	case "C" :
        	return toSiValue(value, unit) - 273.15;
        break;
        case "F" :
        	return (toSiValue(value, unit) - 273.15) * 180.0/100.0 + 32.0;      
        break;
        case "K" :
        	return toSiValue(value, unit);
        break;
    }
}