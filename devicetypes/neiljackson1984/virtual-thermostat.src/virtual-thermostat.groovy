/**
 * Virtual Thermostat
 * copyright 2018 Neil Jackson
 *  This device handler is designed to be created as a child device of the Virtual Thermostat SmartApp.
 *  Edit me at https://graph-na04-useast2.api.smartthings.com/ide/device/editor/221620c6-0d27-445a-96cd-5aa61bdc6814
 */
 
include 'asynchttp_v1'
//include 'asynchttp'
 
metadata {
	definition (name: "Virtual Thermostat", namespace: "neiljackson1984", author: "Neil Jackson") {
    	//TAGGING CAPABILITIES: ('tagging' implies that these capabilities have no attributes, and have no commands)
        
        capability "Actuator"  //The "Actuator" capability is simply a marker to inform SmartThings that this device has commands     
        //attributes: (none)
        //commands:  (none)
        
        capability "Sensor"   //The "Sensor" capability is simply a marker to inform SmartThings that this device has attributes     
        //attributes: (none)
        //commands:  (none)
        
        
		capability "Thermostat Cooling Setpoint"
        //attributes: coolingSetpoint
        //commands: setCoolingSetpoint
        
		capability "Thermostat Fan Mode"
        //attributes: thermostatFanMode, supportedThermostatFanModes
        //commands: fanAuto, fanCirculate, fanOn, setThermostatFanMode
        
		capability "Thermostat Heating Setpoint"
        //attributes: heatingSetpoint
        //commands: setHeatingSetpoint
        
		capability "Thermostat Mode"
        //attributes: thermostatMode, supportedThermostatModes
        //commands: auto, cool, emergencyHeat, heat, 'off', setThermostatMode
        
		capability "Thermostat Operating State"
        //attributes: thermostatOperatingState
        //commands: (none)
        
		//  capability "Thermostat Schedule"
        //  //attributes: schedule
        //  //commands: setSchedule
        
        capability "Temperature Measurement"
        //attributes: temperature
        //commands: (none)
        
        capability "Switch"
        //attributes: enum switch
        //commands: on(), off()
        
        capability "Image Capture"
        //attributes: String image
        //commands: take()
        
        attribute ("setpoint", "number");
        command( "setSetpoint", ["number"]);  // I might as well leave this as an internal function since it is not part of a published standard. -- ahah- i must designate it an official command in order to be able to call it as an action from a controlTile.
        
        attribute( "controlError", "number" ); //this will be (actual temperature) - (desired temperature)
        attribute( "integralOfControlError", "number" );
        attribute( "derivativeOfControlError", "number" );
        attribute( "controlOutputForce", "number" );
        attribute( "lastControlUpdateTime", "number" );
        attribute( "controllerIterationReport", "string" );  // a human-readable multi-line report that will be generated by updateController().
        attribute("lastNonOffThermostatMode", "string");
        
        
        //displayableSetpoint and displayableTemperature are hacks to work around the fact that the magic string replacement that the smarthtings ui does in the label of tiles does not provide any way to display the unit of an attribute value.
        // the kludge is to send a "displayableTemperature" event whenever I send a "temperature" event, and same for "displayableSetpoint"
		attribute( "displayableTemperature", "string" ); 
        attribute( "displayableSetpoint", "string" ); 
        attribute( "debugMessage", "string");
		
		//the "controlUpdateRequested" attribute provides a means for code in this device handler to request that the updateController() function be executed.
        // The parent smartapp subscribes to the controlUpdateRequested attribute, and, when it sees a change in the value of the attribute, will call the updateController() method of the child thermostat.
        // the reason that we do it in this roundabout way, rathern than simply calling updateController() directly is to allow any sendEvent() functions to finish propagating, so that the updated attribute values 
        // that the sendEvent() calls caused will be available to updateController() when it runs.
        // the value can be anything as long as it represents a change.
		//attribute( "controlUpdateRequested", "number" );

        
        //these commands exist solely to support the tile-based ui:
        command("switchMode", ["string"]);
        command("increaseSetpoint");
        command("decreaseSetpoint");
        command("resetIntegralButtonHandler");
        command("updateControllerButtonHandler");
        //command("runTheTestCode");
        
        attribute("temperatures", "string");
        //attribute("foo", "number");
        
        attribute('imageB','string');
        command('captureImageB');
}


	simulator {	}

	tiles(scale : 2) {
		multiAttributeTile(name:"thermostatMulti", type:"thermostat", width:6, height:4, canChangeIcon: true) {
			tileAttribute("device.displayableTemperature", key: "PRIMARY_CONTROL") {
				attributeState("arbitraryStringHere", label:'${currentValue}', defaultState: true)
			}
            tileAttribute("device.displayableSetpoint", key: "VALUE_CONTROL") {
				attributeState("VALUE_UP",  action: "increaseSetpoint")
                attributeState("VALUE_DOWN",  action: "decreaseSetpoint")
			}
			tileAttribute("device.thermostatOperatingState", key: "OPERATING_STATE") {
				attributeState("idle", backgroundColor:"#44b621")
				attributeState("heating", backgroundColor:"#ffa81e")
                attributeState("cooling", backgroundColor:"#00A0DC")
			}
			tileAttribute("device.thermostatMode", key: "THERMOSTAT_MODE") {
				attributeState("default", label:'mode: undefined', defaultState: true)
                attributeState("off", label:'mode: ${name}', icon: "http://cdn.device-icons.smartthings.com/thermostat/heating-cooling-off-icn@2x.png")
                attributeState("heat", label:'mode: ${name}', icon: "http://cdn.device-icons.smartthings.com/thermostat/heat-icn@2x.png")
                attributeState("cool", label:'mode: ${name}', icon: 'http://cdn.device-icons.smartthings.com/thermostat/cool-icn@2x.png')
				attributeState("auto", label:'mode: ${name}', icon: "http://cdn.device-icons.smartthings.com/thermostat/auto-icn@2x.png")
			}
            tileAttribute("device.thermostatMode", key: "SECONDARY_CONTROL") {
				attributeState("default", label:'mode: undefined', defaultState: true)
                attributeState("off", label:'mode: ${name}', icon: "http://cdn.device-icons.smartthings.com/thermostat/heating-cooling-off-icn@2x.png")
                attributeState("heat", label:'mode: ${name}', icon: "http://cdn.device-icons.smartthings.com/thermostat/heat-icn@2x.png")
                attributeState("cool", label:'mode: ${name}', icon: 'http://cdn.device-icons.smartthings.com/thermostat/cool-icn@2x.png')
				attributeState("auto", label:'mode: ${name}', icon: "http://cdn.device-icons.smartthings.com/thermostat/auto-icn@2x.png")
			}
            tileAttribute("device.heatingSetpoint", key: "HEATING_SETPOINT") {
            	attributeState("arbitraryStringHere", label:'${currentValue}')
            }
            tileAttribute("device.coolingSetpoint", key: "COOLING_SETPOINT") {
            	attributeState("arbitraryStringHere", label:'${currentValue}')
            }
		}
        
        standardTile("mode", "device.thermostatMode", width: 3, height: 1, decoration: "flat") {
			state "default", defaultState: true, 	/* backgroundColor: "#FFFFFF", */ /*icon: null,																					*/	label:'mode: unknown', 		action:"switchMode", 	nextState:"changingToOff" 			
            state "auto",							/* backgroundColor: "#BF74CC", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/auto-icn@2x.png",					*/	label:'mode: ${name}',		action:"switchMode",	nextState:"changingToCool"			
            state "cool",							/* backgroundColor: "#00A0DC", */ /*icon: 'http://cdn.device-icons.smartthings.com/thermostat/cool-icn@2x.png',					*/	label:'mode: ${name}',		action:"switchMode",	nextState:"changingToHeat"			
            state "heat",							/* backgroundColor: "#E86D13", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/heat-icn@2x.png",					*/	label:'mode: ${name}',		action:"switchMode",	nextState:"changingToOff"			         
            state "off",		        			/* backgroundColor: "#FFFFFF", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/heating-cooling-off-icn@2x.png",	*/	label:'mode: ${name}', 		action:"switchMode", 	nextState:"changingToAuto"
            
            state "changingToAuto",      			/* backgroundColor: "#c7a7cc", */ 																									label:'changing to auto',	/* action:null,	*/		nextState:"changingToAuto"
            state "changingToCool",      			/* backgroundColor: "#9acadc", */ 																									label:'changing to cool',	/* action:null,	*/		nextState:"changingToCool"
            state "changingToHeat",      			/* backgroundColor: "#e8ba99", */ 																									label:'changing to heat',	/* action:null,	*/		nextState:"changingToHeat"
			state "changingToOff",       			/* backgroundColor: "#d6d6d6", */ 																									label:'changing to off',	/* action:null,	*/		nextState:"changingToOff"
            /* 
           
*/            
            
            // useful icon reference: http://htmlpreview.github.io/?https://github.com/krlaframboise/Resources/blob/master/SmartThings-Icons.html
            
          
            //strictly speaking, in the magic string replacement that the platform does in the label text, ${name} is replaced with whatever the first argument to the state() function is, whereas ${currentValue} is replaced with the value of the attribute that this tile represents.
            // magic-string replacement does not occur in the icon  parameter, unfortunately, only in the label parmaeter it seems.
        }
        
        standardTile("offButton", "device.thermostatMode", width: 1, height: 1, decoration: "flat") {
			state "default", defaultState: true, 	/* backgroundColor: "#FFFFFF", */ /*icon: null,																					*/	label:'off()', 		action:"off", 	nextState:"changingToOff" 			
            
            state "auto",							/* backgroundColor: "#BF74CC", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/auto-icn@2x.png",					*/	label:'off()',		action:"off",	nextState:"changingToOff"			
            state "cool",							/* backgroundColor: "#00A0DC", */ /*icon: 'http://cdn.device-icons.smartthings.com/thermostat/cool-icn@2x.png',					*/	label:'off()',		action:"off",	nextState:"changingToOff"			
            state "heat",							/* backgroundColor: "#E86D13", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/heat-icn@2x.png",					*/	label:'off()',		action:"off",	nextState:"changingToOff"			         
            state "off",		        			/* backgroundColor: "#FFFFFF", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/heating-cooling-off-icn@2x.png",	*/	label:'off()', 		action:"off" 	/* nextState:"changingToOff"*/
            
            state "changingToOff",      				/* backgroundColor: "#c7a7cc", */ 																								 label:'changing mode to off',	action:null,			nextState:"changingToOff"
        }
        
        standardTile("autoButton", "device.thermostatMode", width: 1, height: 1, decoration: "flat") {
			state "default", defaultState: true, 	/* backgroundColor: "#FFFFFF", */ /*icon: null,																					*/	label:'auto()', 		action:"auto", 	nextState:"changingToOff" 			
            
            state "auto",							/* backgroundColor: "#BF74CC", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/auto-icn@2x.png",					*/	label:'auto()',		action:"auto"	/* nextState:"changingToAuto"	*/		
            state "cool",							/* backgroundColor: "#00A0DC", */ /*icon: 'http://cdn.device-icons.smartthings.com/thermostat/cool-icn@2x.png',					*/	label:'auto()',		action:"auto",	nextState:"changingToAuto"			
            state "heat",							/* backgroundColor: "#E86D13", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/heat-icn@2x.png",					*/	label:'auto()',		action:"auto",	nextState:"changingToAuto"			         
            state "off",		        			/* backgroundColor: "#FFFFFF", */ /*icon: "http://cdn.device-icons.smartthings.com/thermostat/heating-cooling-off-icn@2x.png",	*/	label:'auto()', 		action:"auto", 	nextState:"changingToAuto"
            
            state "changingToAuto",      				/* backgroundColor: "#c7a7cc", */ 																								 label:'changing mode to auto',	action:null,			nextState:"changingToAuto"
        }
        
        standardTile("onButton", "device.lastNonOffThermostatMode", width: 1, height: 1, decoration: "flat") {
			state "default", defaultState: true, 	/* backgroundColor: "#FFFFFF", */ /*icon: null,																					*/	label:'on() (${currentValue})', 		action:"on" 		    
        }
        
        valueTile("temperature", "device.displayableTemperature", width: 3, height: 1, decoration: "flat"){
        	state "default", label:'temperature: ${currentValue}', defaultState:true
        }
        valueTile("temperatures", "device.temperatures", width: 3, height: 1, decoration: "flat"){
        	state "default", label:'temperatures: ${currentValue}', defaultState:true
        }
        
        valueTile("setpoint", "device.displayableSetpoint", width: 3, height: 1, decoration: "flat"){
        	state "default", label:'setpoint: ${currentValue}', defaultState:true
            
            //state "default", label:'setpoint:\u00A078.0\u00A0F', defaultState:true
			// the text flowing for labels does not ditinguish between regular and nonbreaking space.
        } 
        standardTile("thermostatOperatingState", "device.thermostatOperatingState", width: 3, height: 1, decoration: "flat"){
        	state "thermostatOperatingState", label:'${name}: ${currentValue}', defaultState: true
        }
        
        //	valueTile("controlError", "device.controlError", width: 2, height: 2, decoration: "flat"){
        //		state "default", label:'controlError: ${currentValue}', unit: "ahoy", defaultState:true
        //	}      
        //	valueTile("integralOfControlError", "device.integralOfControlError", width: 2, height: 2, decoration: "flat"){
        //		state "default", label:'integralOfControlError: ${currentValue}', unit: "ahoy", defaultState:true
        //	}       
        //	valueTile("derivativeOfControlError", "device.derivativeOfControlError", width: 2, height: 2, decoration: "flat"){
        //		state "default", label:'derivativeOfControlError: ${currentValue}', unit: "ahoy", defaultState:true
        //	}        
        //	valueTile("controlOutputForce", "device.controlOutputForce", width: 2, height: 2, decoration: "flat"){
        //		state "default", label:'controlOutputForce: ${currentValue}', unit: "ahoy", defaultState:true
        //	}        
        //	valueTile("lastControlUpdateTime", "device.lastControlUpdateTime", width: 2, height: 2, decoration: "flat"){
        //		state "default", label:'lastControlUpdateTime: ${currentValue}', unit: "ahoy", defaultState:true
        //	} 
        
        standardTile("updateControllerButton", "whatever", width: 1, height: 1, decoration: "flat"){
        	state "default", label:'updateController()', unit: "ahoy", defaultState:true, action:"updateControllerButtonHandler"
        }        
        standardTile("resetIntegralButton", "whatever", width: 1, height: 1, decoration: "flat"){
        	state "default", label:'resetIntegral()', unit: "ahoy", defaultState:true, action:"resetIntegralButtonHandler"
        }        
        standardTile("controllerIterationReport", "device.controllerIterationReport", width: 6, height: 6, decoration: "flat", alignment: 'left', align: 'left', style: 'text-align:left'){
        	state "default", label:'${currentValue}', defaultState:true //action:"resetIntegral"
        }
        
        standardTile("take", "device.image", width: 1, height: 1, canChangeIcon: false, inactiveLabel: true, canChangeBackground: false) {
            state "take", label: "Take", action: "Image Capture.take", icon: "st.camera.dropcam", backgroundColor: "#FFFFFF", nextState:"taking"
            state "taking", label:'Taking', action: "", icon: "st.camera.dropcam", backgroundColor: "#00A0DC"
            state "image", label: "Take", action: "Image Capture.take", icon: "st.camera.dropcam", backgroundColor: "#FFFFFF", nextState:"taking"
    	}

        
        carouselTile("performanceGraph", "device.image", width: 12, height: 9) {
        	state "image", label:"ahoy", action:"Image Capture.take", defaultState:true
        }
        
       // carouselTile('imageB', "device.imageB", width:4, height:4) {
       // 	state "imageB", label:"ahoy",  defaultState:true
       // }
        
         standardTile("captureImageBButton", "device.imageB", width: 1, height: 1, decoration: "flat"){
        	state "imageB", label:'captureImageB()', defaultState:true, action:"captureImageB", nextState:"capturing"
            state "capturing", label:'capturing...', action: "", icon: "st.camera.dropcam", backgroundColor: "#00A0DC"
        }        
        
       ////  controlTile(
		////  	"setpointControlTile",            // String tileName -- a unique name, to be used as an argument to the main() or details() function below
		////  	"device.setpoint",                // String attributeName 
		////  	"control",                        // String controlType  --  expected to be one of {"slider", "control"}
       ////      width:                     3,   // Integer	controls how wide the tile is. Default is 1.
       ////      height:                    3,   // Integer	controls how tall this tile is. Default is 1.
       ////      canChangeIcon:         false,   // Boolean	true to allow the user to pick their own icon. Defaults to false.
       ////      canChangeBackground:   false,   // Boolean	true to allow a user to choose their own background image for the tile. Defaults to false.
       ////      decoration:           'flat',   // String	specify "flat" for the tile to render without a ring.
       ////      //range:                   null,   // String	used to specify a custom range. In the form of "(<lower bound>..<upper bound>)"
       ////      inactiveLabel:         false    //undocumented options
       ////  ){
       ////  	state(
       ////                                  "setpoint",    // String stateName - the name of the attribute value for which to display this state for.
       ////          action:           'setSetpoint',    // String	the action to take when this tile is pressed. The form is <capabilityReference>.<command>.
       ////          //backgroundColor:           null,    // String	a hexadecimal color code to use for the background color. This has no effect if the tile has decoration: “flat”.
       ////          //backgroundColors:          null,    // 	String	specify a list of maps of attribute values and colors. The mobile app will match and interpolate between these entries to select a color based on the value of the attribute.
       ////          defaultState:              true,    // 	Boolean	specify true if this state should be the active state displayed for this tile.
       ////          //icon:                      null,    // 	String	the identifier of the icon to use for this state.
       ////         label: 'ahoy'                       // 	String	the label for this state. 
       ////     )
       ////     state("VALUE_UP", label: '${currentValue.round(2)}', action: "increaseSetpoint")
       ////     state("VALUE_DOWN", label: '${currentValue.toString().toFloat().round(2)}', action: "decreaseSetpoint")
       ////  }
        

        main ("thermostatMulti")
        details(
        	[
            	"thermostatMulti", 
                "mode",
                "thermostatOperatingState",
                "temperature",
                //"temperatures",
                "setpoint", 
                
 
                
                "offButton",
                "autoButton",
                "onButton",
                "updateControllerButton",
                "resetIntegralButton",
                     "take",
               "performanceGraph",
                "controllerIterationReport",
                //"imageB",
                //"captureImageBButton"
             
              
            ]
        )
    }
    
    preferences{
    	section(){
            paragraph("the controller will wait this long after changing the state of a heater or cooler before changing the state again. (prevents rapid cycling)");
            //Remember, Multiple page preferences and dynamic preferences pages are not supported in Device Handlers (only in SmartApps).
            // the smartapps preferences pages are much more flexible than the device preferences page, so perhaps we ought to put all preference entry there.
            input( 
                name: "holdoffDuration",
                title: "holdoffDuration (seconds): \nthe controller will wait this long after changing the state of a heater or cooler before changing the state again. (prevents rapid cycling)", 
                type: "number",
                description: "the controller will wait this long after changing the state of a heater or cooler before changing the state again. (prevents rapid cycling)", 
                required: false, 
                defaultValue: getSetting("holdoffDuration")
            );
            
            input( 
                name: "pCoefficient",
                title: "pCoefficient ([output force]/Kelvin): \nThis is the p coefficient of the PID controller.", 
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getSetting("pCoefficient")
            );
            
            input( 
                name: "iCoefficient",
                title: "iCoefficient ([output force]/(Kelvin * seconds): \nThis is the i coefficient of the PID controller.", 
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getSetting("iCoefficient")
            );
            
            input( 
                name: "dCoefficient",
                title: "dCoefficient ([output force]/(Kelvin/seconds): \nThis is the d coefficient of the PID controller. (not yet supported - this value will be ignored.)", 
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getSetting("dCoefficient")
            );
            
            input( 
                name: "powerOfHeaters",
                title: "powerOfHeaters ([output force]): \nThis is an input that allows you to tell the controller what (magnitude of) the power of the heaters (collectively) is.  " + 
                	"Because the ultimate output of the controller is just one of the the three values {heat, cool, or off}, the meaning of the powerOfHeaters setting is not " + 
                    "well-defined in physical terms.  The effect of powerOfHeaters and powerOfCoolers is to set the relative size of the off-to-heat and off-to-cool deadbands." +
                    "the algorithm will attend to only the absolute value, and not the sign, of this number."
                    ,
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getSetting("powerOfHeaters")
            );
            
            input( 
                name: "powerOfCoolers",
                title: "powerOfCoolers([output force]): \nAnalogous to powerOfHeaters, decribed above.", 
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getSetting("powerOfCoolers")
            );
            
            input( 
                name: "graphDuration",
                title: "graphDuration (seconds)", 
                type: "number",
                description: "", 
                required: false, 
                defaultValue: getSetting("graphDuration")
                
               
            );
            
        }
    }
}


def sendDebugMessage(x)
{
    sendEvent(name: "debugMessage", value: 
        (new Date()).format(preferredDateFormat, location.getTimeZone()) + "\n" +
        x
    )
}

def runTheTestCode()
{
    //log.debug "runTheTestCode() ran";
    def m = [
        [2,4,8],
        [3,6,13]
    ];
    
   // sendDebugMessage("ahoy");
    // def returnData = 
        // "m: " + "\n" + m.join("\n") + "\n\n" +
        // "ref(m): " + "\n" + ref(m).join("\n") + "\n\n" +
        // "rref(m): " + "\n" + rref(m).join("\n");
    
    // def result = rangeIntersection([10,15.1], [8,17]);
    def result;
    try{
        result = intersectionPointOfLineSegments(
            [
                
                [1,1],
                [0,0]
            ],
            [
                [0.5,0.5],
                [2,2]
            ]
        
        );
    } catch(e) 
    {
        result = e;
        sendDebugMessage(e);
        throw(e);
    }
    def returnData = "result: " + result;
    take();
    return  render( contentType: "text/html", data: returnData, status: 200);
    //return ['myKey' : 'myValue'];
}

//=============functions that serve as click handlers for the tile-based ui:
def switchMode(arg)
{
 	log.debug "switchMode was called " + "with arg: " + arg;
    switch(device.currentState("thermostatMode")?.getStringValue())
    {
    	case 'auto': setThermostatMode('cool'); break;
        case 'cool': setThermostatMode('heat'); break;
        case 'heat': setThermostatMode('off'); break;
        case 'off': setThermostatMode('auto'); break;
        //case 'emergency heat': 	...
        //case 'eco':				...
        //case 'rush hour':			...
        default: setThermostatMode('off'); break;
    }
}

def increaseSetpoint()
{
	log.debug "increaseSetpoint was called "//with arg: " + arg;
    nudgeSetpoint(+0.1);
}

def decreaseSetpoint()
{
	log.debug "decreaseSetpoint was called"// with arg: " + arg;
    nudgeSetpoint(-0.1);
    
}

def nudgeSetpoint(x)
{
	setSetpoint((device.currentState("setpoint").getFloatValue() + x).round(2));
}

def resetIntegralButtonHandler()
{
	resetIntegral();
    updateController(cause:"resetIntegral() button was clicked.");
}

def updateControllerButtonHandler()
{
	updateController(cause:"updateController() button was clicked.");
}

//def requestControllerUpdate(Map data=[:])
//{
//	sendEvent(name: 'controlUpdateRequested', value: (new Date()).getTime(), data:data);
//}

def resetIntegral()
{
	sendEvent(name: "integralOfControlError",   value: 0.0, unit: "K*s");
}

//===== PREFERENCE GETTERS
//we need preference getters, instead of simply reading the preference values,
// because it can happen that this device is running without the user ever having clicked through the preferences page.
// this is most likely in the case where this device is created as a child device of some other device or smartapp.  
// If the user hasn't clicked through the preferences pages, then the preference values will all be null, and we need to have default values.functions that serve as getters for the preferences, which are necessary to provide the default values in case the user has never clicked through the preferences page (and therefore the settings object isn't populated with all  of the keys declared in the preferences metadata above)
def getDefaultSettings(){
	return \
    	[
        	'holdoffDuration'  : 113,
            'pCoefficient'     : -1,
            'iCoefficient'     : -0.000001,
            'dCoefficient'     : 0,
            'powerOfHeaters'   : 1,
            'powerOfCoolers'   : 1,
            'graphDuration'    : 60*60*4
        ];
}

def getSetting(nameOfSetting){
	return settings?.containsKey(nameOfSetting) ? settings[nameOfSetting] : getDefaultSettings()[nameOfSetting];
    //return settings[nameOfSetting] ?: getDefaultSettings()[nameOfSetting];
}

// parse events into attributes
def parse(String description) {
	log.debug "Parsing '${description}'"
	// TODO: handle 'coolingSetpoint' attribute
	// TODO: handle 'thermostatFanMode' attribute
	// TODO: handle 'supportedThermostatFanModes' attribute
	// TODO: handle 'heatingSetpoint' attribute
	// TODO: handle 'thermostatMode' attribute
	// TODO: handle 'supportedThermostatModes' attribute
	// TODO: handle 'thermostatOperatingState' attribute
	// TODO: handle 'schedule' attribute
	// TODO: handle 'thermostatSetpoint' attribute
}

def setTemperature(float value, String unit){
	//we prefer not to do a pass through toSiValue to avoid creating a number with a lot of digits after the decimal point, which there is no good way to round at the time of display, and so looks ugly in the ui.
	float valueInLocalUnits = (unit == location.getTemperatureScale()   ?    value :  toValueInLocalUnits(toSiValue(value, unit), "K"));   
    sendEvent(
    name: "temperature",  
        value: valueInLocalUnits, 
        unit: location.getTemperatureScale()
    );
    
    sendEvent(
        name: "displayableTemperature", 
        value: valueInLocalUnits + " \u00b0" + location.getTemperatureScale()
    )
    
    
    // I am passing the new temperature to updateController as an argument rather than letting updateController() read the latest state because I suspect that the above sendEvent() will not have taken effect fully when I call updateController() immediately below.  //TO DO: use device.state to overcome this problem.
    //state.temperature = toSiValue(value, unit);
    updateController(cause: "setTemperature");
}

def setTemperature(float value){
	setTemperature(value, location.getTemperatureScale());
}

def setTemperature(List states){
	//log.debug("states: " + states)
    float valueInLocalUnits = states.sum{it.getUnit() == location.getTemperatureScale()   ?    it.getFloatValue() :  toValueInLocalUnits(toSiValue(it.getValue(), it.getUnit()), "K") }/states.size();
    sendEvent(name:"temperatures", value: states.collect{[it.getDevice().name, it.getValue(), it.getUnit()]})
    
    setTemperature(valueInLocalUnits);
}

def setTemperature(state){
	setTemperature(state.getFloatValue(), state.getUnit());
}

// the parent SmartApp will invoke this method to tell the virtual thermostat to take a look at the thermometer's current reading and
// take action as needed.  This is where the meat of the control algorithm is.
def updateController(Map options=[:]){
	//the SmartThings documentation (see https://docs.smartthings.com/en/latest/cloud-and-lan-connected-device-types-developers-guide/building-lan-connected-device-types/building-the-service-manager.html?highlight=parent#best-practices)
    // mentions that the best practice is to not have a child device make calls to the parent smartapp, but instead have the
    // parent smart app pass all necessary information to the methods of the child device as arguments.
    // I am intentionally violating that rule here to see what happens and because it seems cleaner to me
    // to have the child device retrieve the temperature from the parent.
    // Then again, I would intuitively think that a device ought to be able to subscribe to events from other devices (which is not the way it really is)
    // so maybe my mental model of a device is a bit different than that intended by the SmartThings architects.
	// update the temperature attribute of this virtual thermostat device to match the temperature attribute of the thermometer of the parent smartApp.
    // (The documentation does not even mention that a device has a getParent() method. )
    // there is a lot of overlap between the concept of SmartApp and the concept of Device.
    
    /*
    	I incorrectly assumed that the attribute value, as retrieved by methods such as device.currentValue(<attributeName>) and device.currentState(<attributeName>).getValue(),
        would not reflect any calls to SendEvent(name: <attributeName>, ...) that had occured in the current execution of the device handler.
        In order to work around this assumed problem, after updating an attribute value, I would trigger the updateController method to be called by a subscription handler in the parent SmartApp.
        
        It turns out that this is unncessary, because an attribute value updated with sendEvent() is immediately available from device.currentValue() and device.currentState().
    */
    //log.debug("updateController(" +  options +  ") was called.");
    long  time 								= (new Date()).getTime();
    float temperature 						= device.currentState('temperature') ? toSiValue(device.currentState('temperature')) : 0; 
    float setpoint 							= toSiValue(device.currentState('setpoint')); 
    long  lastControlUpdateTime 			= device.currentState('lastControlUpdateTime')?.getLongValue() ?: time;
	float timeElapsedSinceLastUpdate  		= ((float)(time - lastControlUpdateTime))/1000.0;
    float lastDerivativeOfControlError 		= device.currentState('derivativeOfControlError')?.getFloatValue()     ?: 0;
    float lastControlError                  = device.currentState('controlError')?.getFloatValue()                ?: 0;                                  
    float lastIntegralOfControlError        = device.currentState('integralOfControlError')?.getFloatValue()       ?: 0;                 
    float lastControlOutputForce            = device.currentState('controlOutputForce')?.getFloatValue()       ?: 0;  
    float controlError 						= temperature - setpoint;
    float derivativeOfControlError;
    float integralOfControlError;
    float controlOutputForce;
    
    
   //compute the derivative of the error  
   if(time == lastControlUpdateTime) //should we also check whether currentTime < lastControlUpdateTime ? Would that ever happen?
   {
   		derivativeOfControlError = lastDerivativeOfControlError;
   } else {
   		derivativeOfControlError = (controlError - lastControlError) / timeElapsedSinceLastUpdate;
   }
   
   //compute the integral of the control error
   integralOfControlError = lastIntegralOfControlError + lastControlError * timeElapsedSinceLastUpdate;

   
   //compute controlOutputForce
   controlOutputForce = 
   		getSetting('pCoefficient') * controlError + getSetting('iCoefficient') * integralOfControlError + getSetting('dCoefficient') * derivativeOfControlError;
   //override controlOutputForce to zero if the mode is off
   if(state.thermostatMode == 'off'){controlOutputForce = 0;}

    //store the necessary state information to be used on the next pass (and for anyone who happens to subscribe to these attributes)
    sendEvent(name: "lastControlUpdateTime",    value: time);
    sendEvent(name: "controlError",             value: controlError, unit: "K"); //to do : express the controlError in the units specified by the location temperature units preference.
    sendEvent(name: "derivativeOfControlError", value: derivativeOfControlError, unit: "K/s");
    sendEvent(name: "integralOfControlError",   value: integralOfControlError, unit: "K*s");
    setControlOutputForce(controlOutputForce);

    def controlUpdateData = 
        [
            'time'                           : time,
            'temperature'                    : temperature,
            'setpoint'                       : setpoint,
            'lastControlUpdateTime'          : lastControlUpdateTime,
            'timeElapsedSinceLastUpdate'     : timeElapsedSinceLastUpdate,
            'lastDerivativeOfControlError'   : lastDerivativeOfControlError,
            'lastControlError'               : lastControlError,
            'lastIntegralOfControlError'     : lastIntegralOfControlError,
            'lastControlOutputForce'         : lastControlOutputForce,
            'controlError'                   : controlError,
            'derivativeOfControlError'       : derivativeOfControlError,
            'integralOfControlError'         : integralOfControlError,
            'controlOutputForce'             : controlOutputForce
        ];

	//def subsequentValuesOfFoo = [];
    //def foo = 0;
    //
    //sendEvent(name: "foo", value: foo++);
	//subsequentValuesOfFoo << device.currentValue("foo");
    //
    //sendEvent(name: "foo", value: foo++);
	//subsequentValuesOfFoo << device.currentState("foo").value;
    //
    //sendEvent(name: "foo", value: foo++);
    
    def newLine = "\n";
    String controllerIterationReport = 
		"====== controllerIterationReport ====="                                                                  + newLine +
        "time: "                        + (new Date(time))                                                        + newLine +
        "timeElapsedSinceLastUpdate: "  + timeElapsedSinceLastUpdate + " seconds"                                        + newLine +
        "cause: "                       + options.cause                                                                  + newLine +
        "setpoint: "                    + setpoint.round(2) + " kelvin"                                                  + newLine +
        "temperature: "                 + temperature.round(2) + " kelvin"                                               + newLine +
        "temperatures: "                + device.currentValue("temperatures")                                            + newLine +
        "controlError: "                + controlError + " kelvin"                                                       + newLine +
        "derivativeOfControlError: "    + derivativeOfControlError + " kelvin/second"                                    + newLine +
        "integralOfControlError: "      + integralOfControlError + " kelvin*second"                                      + newLine +
        "controlOutputForce: "          + controlOutputForce                                                             + newLine +
        "status of heaters:"                                                                                             + newLine +
        	getParent().heaters.inject(""){result, item -> result + "\t" + item + ": " + item.currentSwitch + newLine}   + newLine +
        "status of coolers:"                                                                                             + newLine +
        	getParent().coolers.inject(""){result, item -> result + "\t" + item + ": " + item.currentSwitch + newLine}   + newLine +
        //"subsequentValuesOfFoo: "       + subsequentValuesOfFoo                                                          + newLine +
        "";
    
    sendEvent(name: "controllerIterationReport",   value: controllerIterationReport, data:state.controlUpdateData);
    if(options.cause == "1 minute interval timer")
    {
    	take();
    }
}


//===== LIFECYCLE METHODS ===============
//even though the documentation does not mention it, it seems that a device handler, much like a smart app, can have 
// an updated() method, and the platform will cal the updated() method whenever the preferences are changed.
def updated(){
	log.debug "Updated with settings: ${settings}";
    unschedule(updateController);
    //unsubscribe();
    initialize();
}

//even though the documentation does not mention it, it seems that a device handler, much like a smart app, can have 
// an installed() method, and the platform will call the installed() method whenever an instance of the device handler is installed.
def installed() {
	log.debug "installed with settings: ${settings}";
    //set the initial attribute values
    setSetpoint(toValueInLocalUnits(toSiValue(70, 'F'), 'K'));
   
    
    initialize();
    setThermostatMode('off');
}

def uninstalled() {
	log.trace "uninstalling"
}


def initialize() {
	// this does not work:
    //subscribe(
    //	getParent().thermometer,
    //    "temperature",
    //    inputHandler
    //)
    //log.debug("getParent().thermometer.dump(): " + getParent().thermometer?.dump());
    //log.debug("getParent().thermometer.inspect(): " + getParent().thermometer?.inspect());
    //log.debug("getParent().thermometer.class: " + getParent().thermometer.class    );
	sendEvent(
    	name: "supportedThermostatModes", 
        value: [
            'auto',
            //'eco',
            //'rush hour',
            'cool',
            //'emergency heat',
            'heat',
            'off'
        ]
     );
     
     //log.debug("device: " + device);
     //log.debug("device.getId(): " + device.getId());
    // log.debug("getGroup(): " + getGroup());
     //log.debug("getParent().getChildThermostat(): " + getParent().getChildThermostat());
     //log.debug("getParent().getChildThermostat(): " + groovy.json.JsonOutput.toJson(getParent().getChildThermostat()));
     //log.debug("getParent().getChildThermostat(): " + groovy.json.JsonOutput.toJson(getParent()));
    //log.debug("getParent().getChildThermostat().inspect(): " + groovy.json.JsonOutput.toJson(getParent().getChildThermostat().inspect()));
    //subscribe(getParent().getChildThermostat(), "temperature", doNothing);   
    
    updateController(cause: "thermostat initialized");
    runEvery1Minute(updateController, [data: [cause: "1 minute interval timer"]]);
}

def doNothing(){
	log.debug "doNothing() was called"
}


//=========  IMPLEMENTATION OF CAPABAILITIES ================


// commands belonging to the "Thermostat Fan Mode" capability:
def fanOn() {
	log.debug "Executing 'fanOn'"
	// TODO: handle 'fanOn' command
}
def fanAuto() {
	log.debug "Executing 'fanAuto'"
	// TODO: handle 'fanAuto' command
}
def fanCirculate() {
	log.debug "Executing 'fanCirculate'"
	// TODO: handle 'fanCirculate' command
}
def setThermostatFanMode() {
	log.debug "Executing 'setThermostatFanMode'"
	// TODO: handle 'setThermostatFanMode' command
}

// commands belonging to the "Thermostat Heating Setpoint" capability:
def setHeatingSetpoint(x) {
	log.debug "setHeatingSetpoint(${x}) was called";
	setSetpoint(x);
}

// commands belonging to the "Thermostat Cooling Setpoint" capability:
def setCoolingSetpoint(x) {
	log.debug "setCoolingSetpoint(${x}) was called";
	setSetpoint(x);
    
}
// commands belonging to the "Thermostat Mode" capability:
def off() {  // this command also belongs to the switch capability
	log.debug "Executing 'off'"
	setThermostatMode('off');
}
def heat() {
	log.debug "Executing 'heat'"
	setThermostatMode('heat');
}
def emergencyHeat() {
	log.debug "Executing 'emergencyHeat'"
	setThermostatMode('emergency heat');
}
def cool() {
	log.debug "Executing 'cool'"
	setThermostatMode('cool');
}
def auto() {
	log.debug "Executing 'auto'"
    setThermostatMode('auto');
}
def setThermostatMode(mode) {
	log.debug "Executing 'setThermostatMode'"
    //log.debug device.currentValue("supportedThermostatModes").dump()
    if(!device.currentValue("supportedThermostatModes").contains(mode))
    {
    	log.trace "setThermostatMode() was called with an argument (${mode}) that is not among the supported thermostat modes of this thermostat (${currentSupportedThermostatModes}).  We will not attempt to change the mode.";
    }
    else 
    {
        if(mode != 'off')
        {
        	sendEvent(name: "lastNonOffThermostatMode", value: mode);
        }        
        def oldMode = device.currentValue("thermostatMode");
        sendEvent(
            name: "thermostatMode",
            value: mode
        );
        
        sendEvent(
        	name: "switch",
            value: (mode == 'off' ? 'off' : 'on')
        )
        
       // if(oldMode != mode){        resetIntegral();}
        updateController('cause':"thermostatMode change from ${oldMode} to ${mode}.");
    }
}

//commands belonging to the "Switch" capabiLity
def on()
{
   /// change the mode to the last non-off mode value auto();
   setThermostatMode(device.currentValue("lastNonOffThermostatMode") ?: 'auto');
}



//commands belonging to the "Image Capture" capability
// see https://docs.smartthings.com/en/latest/cloud-and-lan-connected-device-types-developers-guide/working-with-images.html
def take()
{
	log.debug "take() was called."
    //log.debug getParent().apiServerUrl('/api/smartapps/installations/' + getParent().getId())
    def graphDuration = getSetting('graphDuration'); //in seconds
    def currentTime = now();
    graphDuration = 40000;
    currentTime = 1535140529253; //debugging only
    def listOfStates;

  def params = [
        uri: 'https://chart.googleapis.com', 
        path: '/chart',
        contentType: 'image/png',
        headers: [
            'Accept-Charset': 'US-ASCII' //this seems to have no efefect.
        ],
        query:
          lineChartQuery(
          	[
                [
                'name': 'setpoint',
                'data': 
                    (listOfStates = unlimitedStatesBetween("setpoint",new Date(currentTime-graphDuration*1000),new Date(currentTime),['includeLatestStatePriorToStartDate':true])).collect{ theState ->
                    	[
                        	theState.getDate().getTime(),
                            theState.getFloatValue()
                        ]
                    }
                //,'interpolationMode': 'flat'
                , 'showClippedLines' : true
                ],
                [
                'name': 'temperature',
                'data':  (listOfStates = unlimitedStatesBetween("temperature",new Date(currentTime-graphDuration*1000), new Date(currentTime),['includeLatestStatePriorToStartDate':true])).collect{ theState ->
                    	[
                        	theState.getDate().getTime(),
                            theState.getFloatValue()
                        ]
                    }
                ]
            ],
            [
                'plotRangeX': [ currentTime - getSetting('graphDuration')*1000,currentTime  ],
                'plotRangeY': [69,80]
            ]
          )
    ];
    

    
    //listOfStates = unlimitedStatesBetween("temperature",new Date(currentTime-3600*24*1000*9), new Date(currentTime), [max:1000]);
    //log.debug "range of times in listOfStates: " + listOfStates.first().getDate().format(preferredDateFormat, location.getTimeZone()) + ", " + listOfStates.last().getDate().format(preferredDateFormat, location.getTimeZone()) ;

       // listOfStates = unlimitedStatesBetween(
          // "lastControlUpdateTime",
          // new Date(currentTime-3600*24*9*1000), //startDate
          // new Date(currentTime),//, //endDate
          // ['max':0]
      // );
      
    //log.debug "listOfStates.size(): " + listOfStates.size();
    // log.debug "listOfStates: " + listOfStates.collect{it.getDate().getTime()};
    //log.debug "(listOfStates[3] == listOfStates[4]): " + (listOfStates[3] == listOfStates[4])
    //log.debug "(listOfStates[0] == listOfStates[1]): " + (listOfStates[0] == listOfStates[1])
    // log.debug "now(): " + now();
    // log.debug "device.currentState('setpoint').getDate().getTime(): " + device.currentState('setpoint').getDate().getTime();
    // log.debug "device.latestState('setpoint').getDate().getTime(): " + device.latestState('setpoint').getDate().getTime();
    // latestState() and currentStte() appear to be totally synonymous.
   
    
    def url = params.uri + params.path + '?' + params.query.collect{k,v -> "${k}=${v}"}.join("&");
    sendDebugMessage "url: " + url;
    
    asynchttp_v1.get(imageResponseHandler, params);
    try { 
        httpGet(params, this.&imageResponseHandler)
        //asynchttp_v1.get(imageResponseHander, params);
    } catch (err) {
        log.debug "Error making request: $err"
    }
}


def imageResponseHandler(response, data=[:]){
    //sendDebugMessage("imageResponseHandler() was called.");    
    log.debug "imageResponseHandler() was called.";
    // we expect a content type of "image/jpeg" from the third party in this case
    if (response.status == 200 && response.headers.'Content-Type'.contains("image/png")) {
        // def imageBytes = response.data
        def message = "";
        def imageUrl;
        def responseType;
        def bytes = [];
        ByteArrayInputStream imageBytes;
        if(response instanceof groovyx.net.http.HttpResponseDecorator)
        {
            log.debug "response is an instanceof HttpResponseDecorator"
            responseType = "groovyx.net.http.HttpResponseDecorator";
            imageBytes = response.data;
        } else if (response instanceof physicalgraph.scheduling.AsyncResponse)
        {
            responseType = "physicalgraph.scheduling.AsyncResponse";
            log.debug "response is an instanceof AsyncResponse"
            //def goodResponse = new groovyx.net.http.HttpResponseDecorator(response.data);
            
            // imageBytes = new ByteArrayInputStream(response.data.getBytes('US-ASCII'));
            imageBytes = new ByteArrayInputStream(response.data.getBytes('ISO-8859-1'));
            // ByteArrayInputStream imageBytes = new ByteArrayInputStream(response.data.getBytes('UTF-8'));
            // ByteArrayInputStream imageBytes = new ByteArrayInputStream(response.data.getBytes());
            //sendDebugMessage("response.data: " + response.data);
            log.debug "response.data.length(): " + response.data.length();
           
            log.debug "response.inspect()" + response.inspect();
            
            response.getHeaders().each{k, v -> log.debug k + ": " + v + "  \n";};
            message += "contentLength: " + response.getHeaders()['Content-Length'] + "  \n";
            message += "response.data.length(): " + response.data.length() + "  \n";
           // message += "response.toString().length(): " + response.toString().length() + "  \n";
           // message += "response.data.getBytes('US-ASCII').size(): " + response.data.getBytes('US-ASCII').size() + "  \n";
            //message += "response.data.getBytes('UTF-8').size(): " + response.data.getBytes('UTF-8').size() + "  \n";
        } 
        message += "responseType: " + responseType;
        if (imageBytes) {
            while (imageBytes.available() > 0){bytes += imageBytes.read();}
            message += "bytes: " + bytes + " \n";
            def stringFromBytes = new String(bytes as byte[]);
            message += "stringFromBytes.length():" + stringFromBytes.length() + "  ";
            message += "stringFromBytes.getBytes('ISO-8859-1'): " + stringFromBytes.getBytes('ISO-8859-1') + " ";
            imageBytes = new ByteArrayInputStream(bytes as byte[]);
            message += "imageBytes.available(): " + imageBytes.available() + "  \n";
            def name = java.util.UUID.randomUUID().toString().replaceAll('-','')
            try {
                storeImage(name, imageBytes, 'image/png');
                imageUrl = getApiServerUrl() + "/api/files/devices/" + device.getId() + "/images/" + name;
                message += "imageUrl: " + imageUrl + "\n";
                //message += "resultOfStoreImage: " + resultOfStoreImage + "\n";
                log.debug("stored image ${name} succesfully.")
                //log.debug "response headers: "+ response.headers.collect {"${it.name} : ${it.value}"}.join(',');
            } catch (e) {
                log.error "Error storing image ${name}: ${e}"
            }
        }
        sendDebugMessage(message);
        
        
        
    } else {
        log.error "Image response not successful or not a jpeg response"
    }
}


//miscellaneous helpers
//this function returns the query map suitable for passing as the query parameter to httpGet when calling the Google image chart service
def lineChartQuery(arg, defaults=[:]){
	//arg is a list of elements of the form 
    // [
    //     name: String name of series, 
    //     color: ..., 
    //     data: [[x0,y0] , [x1,y1], ...],
    //     plotRangeX: [xMin, xMax],
    //     plotRangeY: [yMin, yMax],
    //     interpolationMode: one of 'flat' or 'linear' (or any false value, which will be treated the same as linear),
    //     interpolateDatumOnTheLeftEdge: (boolean specifying whether to add a datum right on the leftEdge (i.e. the minimum X edge) of the chart.
    //     interpolateDatumOnTheRightEdge: (boolean specifying whether to add a datum right on the rightEdge (i.e. the minimum X edge) of the chart.
    //     showClippedLines (supersedes the 'interpolateDatumOn...' options //if one endpoint of a line segment is outside of the plot range, the google chart default is not
    // to display that line segment.  showClippedLines, if set to true, will cause those clipped line segments to be displayed.
    //
    // ]
    //  The two interpolateDatumOn... options above are useful in the case where you wnat to plot a time series 
    //  map whose keys are strings - names of the series, and whose values are lists of two-element lists of numbers - cartesian coordinates.
    //defaults is a map that contains settings that we will apply to each data series in arg, unless that series explicitly contains the same setting.
    def query = [:];
    query['cht'] = 'lxy'; //chart type is lineXY
   // query['chds'] = //'a'; //auto scaling (documentation suggest that this only has effect if the data is in the "text" format.
    query['chco'] = "FF0000,00FF00,0000FF";
    query['chdl'] =  arg.collect{it['name'] ?: ''}.join('|');
    def naturalPlotRangeX = {x->[x.min(),x.max()]}(arg.sum{it['data'].collect{it[0]}});
    def naturalPlotRangeY = {x->[x.min(),x.max()]}(arg.sum{it['data'].collect{it[1]}});
    //ensure that each item has a 'rangeX' and a 'rangeY'
    
    arg = arg.collect{
        it = defaults + it;
        if(!it.containsKey('plotRangeX')){
            //log.debug "using naturalPlotRangeX: " + naturalPlotRangeX
            it['plotRangeX'] = naturalPlotRangeX;
        }
        if(!it.containsKey('plotRangeY')){
            it['plotRangeY'] = naturalPlotRangeY;
        }
        it.data = it.data.sort{datum -> datum[0]}
        if(it.interpolationMode == 'flat')
        {
            def newData = [];
            it.data.eachWithIndex{ element, index ->
                if(index > 0)
                {
                    newData.add(
                        [
                            element[0],
                            it.data[index-1][1]
                        ]
                    );
                }                
                newData.add(element);
            }
            it.data = newData;
        }
        
        if(false){
            def latestDatumLeftOfLeftEdge = null;
            def numberOfDataLeftOfLeftEdge = 0;
            it.data = it.data.dropWhile{
                datum ->
                log.debug "datum[0]: " + datum[0]
                log.debug "it.plotRangeX.min(): " + it.plotRangeX.min()
                if(datum[0] < it.plotRangeX.min())
                {
                    latestDatumLeftOfLeftEdge = datum; //I am trusting that dropWhile will consider the elements in order starting with the first, so that, when dropWhile is finished, latestDatumOfLeftEdge will be correctly assigned as the latest datum left of the left edge of the rangeX (or null if there are no data left of the left edge)
                    numberOfDataLeftOfLeftEdge++;
                    log.debug "found a datum left of left edge: ${datum}"
                    return true;
                } else {
                    return false;
                }
            };
            log.debug "there was ${numberOfDataLeftOfLeftEdge} datums left of the left edge, the latestOfWhich is ${latestDatumLeftOfLeftEdge}."
            
            if(it.data && latestDatumLeftOfLeftEdge)
            {
                def newFirstDatum = 
                    [ 
                        it.plotRangeX.min(),
                        latestDatumLeftOfLeftEdge[1] + (it.data.first()[1] - latestDatumLeftOfLeftEdge[1])/(it.data.first()[0] - latestDatumLeftOfLeftEdge[0]) * (it.plotRangeX[0] - latestDatumLeftOfLeftEdge[0])
                    ];
                def message =  "before adding newFirstDatum, it.data.size() is " + it.data.size() 
                it.data.add(0, newFirstDatum); 
               // log.debug "newFirstDatum: " + newFirstDatum;
               message += " and after adding newFirstDatum, it.data.size() is " + it.data.size()  
               log.debug message
            }
        }
        
        if(it.showClippedLines)
        {
            def newData = [];
            def plotRange = [it.plotRangeX, it.plotRangeY];
            //log.debug "plotRange: " + plotRange;
            def pointIsInPlotRange = {point -> return valueIsInRange(point[0], plotRange[0]) && valueIsInRange(point[1], plotRange[1]);}; 
            def plotRangeBoundarySegments = 
                [
                    //bottom:
                    [
                        [plotRange[0][0],plotRange[1][0]],
                        [plotRange[0][1],plotRange[1][0]],
                    ],
                    //right :
                    [
                        [plotRange[0][1],plotRange[1][0]],
                        [plotRange[0][1],plotRange[1][1]],
                    ], 
                    //top :
                    [
                        [plotRange[0][1],plotRange[1][1]],
                        [plotRange[0][0],plotRange[1][1]],
                    ], 
                    //left:
                     [
                        [plotRange[0][0],plotRange[1][1]],
                        [plotRange[0][0],plotRange[1][0]],
                    ]                   
                ];
            def intersectionOfLineSegmentWithPlotRangeBoundary = {segment -> 
                def intersectionPoint = null;
                def i =0;
                while(!intersectionPoint && i<plotRangeBoundarySegments.size())
                {
                    intersectionPoint = intersectionPointOfLineSegments(segment, plotRangeBoundarySegments[i]);
                }
                return intersectionPoint;
            }
            
            def thisPoint = it.data?.first();
            def thisPointIsInPlotRange;
            def lastPoint;
            def lastPointWasInPlotRange;
            if(thisPoint && (thisPointIsInPlotRange = pointIsInPlotRange(thisPoint)))
            {
                newData += [thisPoint];
            }
            lastPoint = thisPoint;
            lastPointWasInPlotRange = thisPointIsInPlotRange;
            
            for(def i = 1; i<it.data.size(); i++){
                thisPoint = it.data[i];
                thisPointIsInPlotRange = pointIsInPlotRange(thisPoint);
                def startPoint = lastPoint;
                def startPointIsInPlotRange = lastPointWasInPlotRange;
                def endPoint   = thisPoint;
                def endPointIsInPlotRange = thisPointIsInPlotRange;
                if(startPointIsInPlotRange && !endPointIsInPlotRange)
                {
                     //in this case, both the startPoint and the endPoint are in the plot range.
                     newData += [endPoint];
                } else if(!startPointIsInPlotRange && endPointIsInPlotRange)
                {
                    //in this case, the startPoint is out of the plot range and the endPoint is in the plot range.
                    newData += [intersectionOfLineSegmentWithPlotRangeBoundary([startPoint, endPoint]), endPoint];
                } else if(startPointIsInPlotRange && !endPointIsInPlotRange)
                {
                    //in this case, the startPoint is in the plot range and the endPoint is out of the plot range.
                    newData += [intersectionOfLineSegmentWithPlotRangeBoundary([startPoint, endPoint])];
                } else  //if(!startPointIsInPlotRange && !endPointIsInPlotRange)
                {
                    //in this case, neither startPoint nor endPoint of this line segment are in the plot range.
                    //do nothing
                    //I suppose it also might be perfectly valid to to do {newData += endPoint;} because it would probably be sufficient to take any line segment that crosses the boundary and split it into two at the crossing point; the google chart api would likely ignore any segments outside the plotRange.
                }
                lastPoint = thisPoint;
                lastPointWasInPlotRange = thisPointIsInPlotRange;                
            }
            
            it.data = newData;
        }
        
        return it;
    }
    
    
    
    
    //set the data scale (which might also be called the plot range depending on which space you are thinking about: the data space or the graphical space of the chart.)
    query['chds'] = arg.sum{
        it['plotRangeX'] +  it['plotRangeY']
     }.join(',');
    query['chd'] = 
    	't:' + 
        arg.collect{
        	it ->
        	[0,1].collect{ 
            	i ->
            	it.data.collect{
                	v -> v[i]                    
                }.join(',')
            }.join('|')
        }.join('|');
     
    query['chtt'] = "ahoy";//new Date().format(preferredDateFormat, location.getTimeZone()); //chart title
     
    // query['chs'] =   "${(int) 158*2}x${(int) 158*1.5}";    //chart size
    // query['chs'] =   "${(int) 158}x${(int) 158}";    //chart size
    query['chs'] =   "${(int) 5}x${(int) 5}";    //chart size
    query['chof'] =  "png";                                 //chart output format

    return query;
    
    
}

//returns the reduced row echelon form of the argument
def rref(m)
{
    m = ref(m);
    
    //we want to insure that every leading coefficient is 1 
    //and is the only nonzero entry in its column
   
   for(def i=m.size()-1; i>=0; i--)
    {   
       
       def thisNumberOfLeadingZeros = numberOfLeadingZeros(m[i]);
       //ensure that all rows above this row have a zero in the position of the leading coefficient of this row
       if(thisNumberOfLeadingZeros < m[i].size())
       {
            //ensure that the leading coefficient is the only non-zero coefficient in its column
            for(def j=i-1; j>=0; j--)
            {
                m[j] = (0..(m[i].size() -1)).collect{index -> m[j][index] - m[i][index] * m[j][thisNumberOfLeadingZeros]/m[i][thisNumberOfLeadingZeros]};
            }   
               //ensure that this row's leading coefficient is 1
            m[i] = (0..(m[i].size() -1)).collect{index -> m[i][index]/m[i][thisNumberOfLeadingZeros]};
       }
    } 
    return m;
}

def intersectionPointOfLineSegments(segment1, segment2){

    //segment1 and segment2 are each a list of the form [startPoint, endPoint]
    //if(segment1[0][1] - segment1[1][0] && segment2[0][0] == segment1[1][0] )
    def matrix = 
        [
            [
                segment1[1][0] - segment1[0][0],
                segment1[1][1] - segment1[0][1]
            ],
            [
                segment2[0][0] - segment2[1][0],
                segment2[0][1] - segment2[1][1]
            ]
        ].transpose();
    
    def augmentedMatrix = 
        (
            matrix.transpose() + 
            [
                [
                    segment2[0][0]-segment1[0][0],
                    segment2[0][1]-segment1[0][1]
                ]
            ]
        ).transpose();
    
    def rrefOfAugmentedMatrix = rref(augmentedMatrix);
    switch(numberOfLeadingZeros(rrefOfAugmentedMatrix[1]))
    {
        case 1:
            //in this case, matrix was invertible, which means there is exactly one solution (which might not actually lie between the endpoints of both line segments, so we have to check that)
            def v = [rrefOfAugmentedMatrix[0][2], rrefOfAugmentedMatrix[1][2]];
            if(v.every{valueIsInRange(it,[0,1])})
            {
                return [
                    (1 - v[0])*segment1[0][0] + v[0]*segment1[1][0],
                    (1 - v[0])*segment1[0][1] + v[0]*segment1[1][1]
                ];
            } else
            {
                return null;
            }
        break;
        case 2:
            //this is the case of the segments being parallel, but not collinear.
            return null;
        break;
        case 3:
            //this is the case of the segments being collinear.
            def x = {y -> -rrefOfAugmentedMatrix[0][1]*y + rrefOfAugmentedMatrix[0][2]};
            def overlappingXRange = rangeIntersection([0,1], [x(0),x(1)]);
            // overlappingXRange is the range of x values satisfying x in [0,1] AND y(x) in [0,1].
            if(overlappingXRange)
            {
                def averageX = overlappingXRange.sum()/2;
                //there are infinitely many solutions lying on the line segments, so for the sake of consistency, I will return exactly one, which is in the middle of the overlapping section of the line segments.
                return [
                    (1 - averageX)*segment1[0][0] + averageX*segment1[1][0],
                    (1 - averageX)*segment1[0][1] + averageX*segment1[1][1]
                ];
            } else
            { 
                return null;
            }
        break;
        default:
            //If I am understanding the problem correctly, we will never get here.  One of the three cases above will obtain.
        break;
    }      
};

//returns the row echelon form of the argument
def ref(m)
{
    //re-arrange the rows as necessary to ensure that the rows are sorted according to number of leading zeros
    
    def numberOfRowsInM=m.size();
    //ensure that numberOfLeadingZeros is STRICTLY increasing as we move from one row to the next.
    for(def i=0; i<m.size(); i++)
    {   
        //sort all rows from row i to the end by numberOfLEadingZeros
        m[i..(numberOfRowsInM-1)] = m.clone()[i..(numberOfRowsInM-1)].sort(this.&numberOfLeadingZeros);
        def thisNumberOfLeadingZeros = numberOfLeadingZeros(m[i]);
        if(thisNumberOfLeadingZeros == m[i].size()){
            //exit the for loop; we're done. this row and all subsequent rows are all zeros.
            break;
        }
        //modify subsequent rows as needed to insure that all subsequent rows have more leading zeros than this one.
        // because of the sort that we did above, we only have to look at rows that have the same number of leading zeros as this one.
        // we can stop as soon as we see a row that has more leading zeros than this one.
        for(def j=i+1; j<m.size() && numberOfLeadingZeros(m[j]) == thisNumberOfLeadingZeros; j++)
        {
            m[j] = (0..(m[i].size() -1)).collect{index -> m[j][index] - m[i][index] * m[j][thisNumberOfLeadingZeros]/m[i][thisNumberOfLeadingZeros]};
        }        
    } 
    return m;
}

def numberOfLeadingZeros(row){ 
    def i;
    for(i=0;i<row.size() && row[i]==0;i++){}
    return i;
};


def valueIsInRange(value, range){ 
    //here range is a a 2-element list of numbers
    return (value >= range.min()) && (value<= range.max());
}; 

def rangeIntersection(range1, range2){
    //range1 and range2 are each a two-element list of numbers
    def ranges = [range1, range2];
    def overlappingRange = [
        ranges.collect{it.min()}.max(),
        ranges.collect{it.max()}.min(),
    ];
    if(overlappingRange[1] >= overlappingRange[0])
    {
        return overlappingRange;
    } else
    { 
        return null;
    }
}

String getPreferredDateFormat()
{
	return "yyyy/MM/dd HH:mm:ss";
}

def getRandomImageUrl()
{    
   return  "https://chart.googleapis.com/chart?chs=100x50&cht=lxy&chtt=" + (new Date()).format("HHmmss", location.getTimeZone())   ;
}

def captureImageB()
{
	log.debug "captureImageB() was called"
    def theUrl = getRandomImageUrl();
	sendEvent(name:"imageB", eventType: 'IMAGE', value: theUrl, data: ['imagePath':getRandomImageUrl()], isStateChange:true)
}

//This functions works almost identically to the built-in function device.statesBetween().  
// The only difference is that, whereas the built-in function has a limit on the number of Events that it will return 
// (the manual says that the limit is 1000 -- in practice, the limit seems to be 200.  It returns the the most recent states first, and, where the result is limited, excludes the olders states from the result.),
//this function will call statesBetween() repeatedly to collect a longer list of events.
//we include the options argument simply to be signature-compatible with the built-in statesBetween() function.
List unlimitedStatesBetween(String attributeName, Date startDate, Date endDate, Map options = [:])
{
    if(options.containsKey('max') && (options['max'] < 1)){return [];}
    
    List states = [];
    List olderStates = [];
    def iterationCounter = 0;
    //def maxAllowedIterations = 10;
    
    //   // I tested a case where there are three sequential states having timetamps (in descending order)   [1535000005699, 1534999945877, 1534999885893]
    //   listOfStates = device.statesBetween(
    //       "lastControlUpdateTime",
    //       new Date(1534999885893), //startDate
    //       new Date(1535000005699), //endDate
    //       ['max':1000]
    //   );
    //   //returns [1534999945877, 1534999885893]
    //   // in other words, statesBetween returns the set of states whose timestamp t satisfisfies startDate <= t < endDate
    //   //or so it would seem; I also obsserved that if I did not guard against statesBetween() returning a state withe timestamp equal to the endDate, then I would get endless looping below,
    // which suggests that sometimes statesBetween will return a state having timetamp equal to endDate.  
    // I incorrectly hypothesized that when there are no states having timestamps in the range [startDate,endDate), but there is a state with timestamp==endDate, that 
    // statesBetween will then return the state with timestamp==endDate.
    // this hypothesis is incorrect, a the following tets demonstrate.
    // so, my working theory is that statesBetween returns all states with timestamps in the range [startDate, endDate), and also (sometimes, for no obvious reason), also returns 
    // the state with timestamp==endDate.
    //   listOfStates = device.statesBetween(
    //       "lastControlUpdateTime",
    //       new Date(1534999945877+1), //startDate
    //       new Date(1535000005699), //endDate
    //       ['max':1000]
    //   );
    // returns []. which means that my theory about statesBetween returning a state whose timestamp equals the endDate in the case where there are no states in the range [startDate, endDate) is wrong.
    //   listOfStates = device.statesBetween(
    //       "lastControlUpdateTime",
    //       new Date(1534999885893), //startDate
    //       new Date(1534999945877), //endDate
    //       ['max':1000]
    //   );
    // returns [1534999945877, 1534999885893]
    //   listOfStates = device.statesBetween(
    //       "lastControlUpdateTime",
    //       new Date(1534999945877), //startDate
    //       new Date(1535000005699), //endDate
    //       ['max':1000]
    //   );
    //returns [1534999945877]
    // suppose there are a large (>> 1000) number of states in the requested range.
    // the 'max' argument behaves as expected for values >= 1.  However, setting 'max':0 produces the same behavior as 
    // omitting the mas parameter entirely, namely: the default value of 10 is used.  setting max:-1 throws an exception.
    
    
    while({
    	//olderStates = device.statesBetween(attributeName, startDate, states?.last()?.getDate() ?: endDate);
        olderStates = 
        	device.statesBetween(
            	attributeName, 
                startDate, 
               // states?.last()?.getDate() ?: endDate  
               //the null check operator above after "states" seems only to check for true nullness not emptiness.  To get the emptiness check, I have to resort to the elvis operator:
                (states ?: null)?.last()?.getDate() ?: endDate,
                ['max':(options['max']?(options['max']-states.size()):1000)]
            );
        //the above specifying of the 'max' parameter to ensure that our own 'max' parameter is satisfied willnot work
        // in the case where options['max']-states.size() is equal to zero.  in this case, we want olderStates to be empty, but the above call
        // to device.sttesBetween will have left olderStates containing possibly as many as 10 elements. (see the note above about the unexpected behavior of the max parameter when 
        // when set to zero.
        // (I am making unlimitedStatesBetween so that it treats its max parameter as expected.  when you ask for max=0, you will get an empty list)
        // I handled this case at the beginning of this function, so, if execution gets here, we can asume that options['max'] >= 1
        if(states && olderStates && (olderStates.first() == states.last())){
        	olderStates.remove(0) //remove the first element of olderStates
        }
        //log.debug ['max':(options['max']?(options['max']-states.size()):1000)]
        iterationCounter++;
        //log.debug "iterated for the ${iterationCounter} time.  states.size()=${states.size()}"
        //bool churningStaleData = states && olderStates && states.last() == olderStates.first();
        states += olderStates;
        //return iterationCounter < maxAllowedIterations && olderStates;
        return olderStates  && (!options.containsKey('max') || states.size() < options['max']) ;
        
        // the above return statement returns a value from the enclosure that will cause us to continue to loop 
        // until either olderStates is empty (i.e. we've already collected all the states that are available in the requested time range)
        // or until we have collected the maximum allowed number of states that the user specified with the 'max' parameter.)
    }()){ continue;}
    //the above while() construction will repeatedly evaluate the enclosure until !olderStates (i.e. until olderStates is an empty list.
    //log.debug "unlimitedStatesBetween had to iterate ${iterationCounter} times in order to gather all ${states.size()} states in the requested time range.";
    if(options['includeLatestStatePriorToStartDate'])  //specifying the 'includeLatestStatePriorToStartDate' as true, we will attempt to inclde the most recent state before startDate, if one exists.
    //this is useful when you are making a time-series graph of the value and you want to know what the value was at the left edge of your graph. 
    {
        def historyDuration = 3600 * 24 * 7 *1000;  //we know that the SmartThings platform does not remember events older than historyDuration (7 days), so we will not bother to look further than endDate - historyDuration.
        olderStates = 
        	device.statesBetween(
            	attributeName, 
                /*startDate: */  new Date(startDate.getTime() - historyDuration), 
                /*endDate: */    startDate,
                ['max':2] //we have to specifiy max of 2 to handle the occasional case where statesBetween returns a state whose timestamp is equal to endDate.
            );
        if(states && olderStates && (olderStates.first() == states.last())){
        	olderStates.remove(0) //remove the first element of olderStates
        } 
        
         //log.debug "found " + olderStates.size() + " states prior to startDate"
         if(olderStates){
             //log.debug "adding " + [olderStates.first()].size() + " prior sstates."
             //log.debug "startDate.getTime(): " + startDate.getTime()
             //log.debug "olderStates.first().getDate().getTime(): " + olderStates.first().getDate().getTime()
             //def message =  "before, states.size() is " + states.size()
             states += [olderStates.first()];
             //message +=  " and after, states.size() is " + states.size();
             //log.debug message
         }
    }
    
    return states; 
}

//custom commands
def setSetpoint(Number x)
{
	log.debug "setSetpoint(${x}) was called";
    
    if(device.currentValue("setpoint") != x) //we probably should do some sort of tolerant equality checkings, so that we only reset the integral when the setpoint is changing by some large amount.  Ideally, this compensation should be done in updateController()
    {
    //	resetIntegral();
    }
  
	sendEvent(
    	name: "setpoint",
        value: x,
        unit: location.getTemperatureScale()
    );
    
    //displayableSetpoint is a hack to work around the fact that the magic string replacement that the smarthtings ui does in the label of tiles does not provide any way to disploay the unit of an attribute value.
    sendEvent(
    	name: "displayableSetpoint",
        value: x + " \u00b0" + location.getTemperatureScale()
    );
    
	sendEvent(
    	name:"coolingSetpoint", 
       	value: x, 
        unit: location.getTemperatureScale()
    );
    
    sendEvent(
    	name:"heatingSetpoint", 
       	value: x, 
        unit: location.getTemperatureScale()
    );
    updateController('cause' : "setSetpoint");
}

def setControlOutputForce(Number x)
{
	//change the state of heaters and coolers as needed to achieve the specified output force.  (I have not yet developed a physical meaning of the magnitude of the output force.
    if(x > 0 && x.abs() > getSetting('powerOfHeaters').abs() && ['auto','heat'].contains(device.currentValue('thermostatMode')))
    {
		turnOffCoolers();
        turnOnHeaters();
        sendEvent(name: "thermostatOperatingState", value: "heating");
    } else if (x < 0 && x.abs() > getSetting('powerOfCoolers').abs() && ['auto','cool'].contains(device.currentValue('thermostatMode')))
    {
    	turnOffHeaters();
    	turnOnCoolers();
        sendEvent(name: "thermostatOperatingState", value: "cooling");
    } else
    {
        turnOffHeaters();
        turnOffCoolers();
        sendEvent(name: "thermostatOperatingState", value: "idle");
    }
    
    sendEvent(
    	name:"controlOutputForce", 
       	value: x, 
        unit: "unitless"
    );
}

def turnOnHeaters()
{
    getParent()?.settings?.heaters?.each{
        if(it.hasCapability("Thermostat") && it.currentValue("supportedThermostatModes").contains('heat'))
        {
            it.setThermostatMode('heat');
            //log.debug "it.currentValue(\"heatingSetpointRange\"): " + it.currentValue("heatingSetpointRange")
            //log.debug "it.currentValue(\"heatingSetpointRange\")?.values(): " + it.currentValue("heatingSetpointRange")?.values()
            //log.debug "it.currentValue(\"heatingSetpointRange\")?.values().max(): " + it.currentValue("heatingSetpointRange")?.values().max()
            it.setHeatingSetpoint(
                it.currentValue("heatingSetpointRange")?.values()?.max() ?: 99
            );
        } else 
        {
            if(it.hasCapability("Thermostat Mode") && it.currentValue("supportedThermostatModes")?.contains('heat')){it.setThermostatMode('heat');}
            if(it.hasCapability("Thermostat Heating Setpoint")){it.setHeatingSetpoint(99);}
            if(it.hasCapability("Switch Level")){it.setLevel(100);}
            if(it.hasCapability("Switch")){it.on();}
        }
    };
}

def turnOffHeaters()
{
	getParent()?.settings?.heaters?.each{
        if(it.hasCapability("Thermostat") && it.currentValue("supportedThermostatModes").contains('off'))
        {
            it.setHeatingSetpoint(
                it.currentValue("heatingSetpointRange")?.values()?.min() ?: 0
            );
            it.off();
        } else 
        {
            if(it.hasCapability("Thermostat Heating Setpoint")){it.setHeatingSetpoint(0);}
            if(it.hasCapability("Thermostat Cooling Setpoint")){it.setCoolingSetpoint(99);}
            if(it.hasCapability("Thermostat Mode") && it.currentValue("supportedThermostatModes")?.contains('off')){it.setThermostatMode('off');}
            if(it.hasCapability("Switch Level")){it.setLevel(0);}
            if(it.hasCapability("Switch")){it.off();}
        }
    };
}

def turnOnCoolers()
{
    getParent()?.settings?.coolers?.each{
        if(it.hasCapability("Thermostat") && it.currentValue("supportedThermostatModes").contains('cool'))
        {
            it.setThermostatMode('cool');
            it.setCoolingSetpoint(
                it.currentValue("coolingSetpointRange")?.values()?.min() ?: 0
            );
        } else 
        {
            if(it.hasCapability("Thermostat Mode") && it.currentValue("supportedThermostatModes")?.contains('cool')){it.setThermostatMode('cool');}
            if(it.hasCapability("Thermostat Cooling Setpoint")){it.setCoolingSetpoint(0);}
            if(it.hasCapability("Switch Level")){it.setLevel(100);}
            if(it.hasCapability("Switch")){it.on();}
        }
    };
}

def turnOffCoolers()
{
    getParent()?.settings?.coolers?.each{
        if(it.hasCapability("Thermostat") && it.currentValue("supportedThermostatModes").contains('off'))
        {
            it.setCoolingSetpoint(
                it.currentValue("coolingSetpointRange")?.values()?.max() ?: 99
            );
            it.off();
        } else 
        {
            if(it.hasCapability("Thermostat Heating Setpoint")){it.setHeatingSetpoint(0);}
            if(it.hasCapability("Thermostat Cooling Setpoint")){it.setCoolingSetpoint(99);}
            if(it.hasCapability("Thermostat Mode") && it.currentValue("supportedThermostatModes")?.contains('off')){it.setThermostatMode('off');}
            if(it.hasCapability("Switch Level")){it.setLevel(0);}
            if(it.hasCapability("Switch")){it.off();}
        }
    };
} 	

//this function, at the moment, only handles temperature
float toSiValue(float value, String unit)
{
	switch(unit) {
    	case "C" :
        	return value + 273.15;
        break;
        case "F" :
        	return (value - 32.0) * 100.0/180.0 + 273.15;
        break;
        case "K" :
        	return value;
        break;
    }
}

def toSiValue(state) //state is expected to be an object returned by calling, for instance, x.currentState("temperature"), where x is a device supporting the "Temperature Measurement" capability.  state is expected to be an object that has a getUnit and a getValue function
{
    return state ? toSiValue(state.getFloatValue(), state.getUnit()) : null;
}

def toValueInLocalUnits(float value, String unit)
{
	switch(location.getTemperatureScale()) {
    	case "C" :
        	return toSiValue(value, unit) - 273.15;
        break;
        case "F" :
        	return (toSiValue(value, unit) - 273.15) * 180.0/100.0 + 32.0;      
        break;
        case "K" :
        	return toSiValue(value, unit);
        break;
    }
}